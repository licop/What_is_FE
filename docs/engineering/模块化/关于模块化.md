# 关于模块化

## 模块化的早期演进过程

### State1-文件划分方式

**具体做法**

将每个功能及其相关状态数据各自单独放到不同的文件中，约定每个文件就是一个独立的模块，使用某个模块就是将这个模块引入到页面中，然后直接调用模块中的成员（变量 / 函数）

**特点**：

- 所有模块都直接在全局工作，没有私有空间，所有成员都可以在模块外部被访问或者修改，
- 而且模块一段多了过后，容易产生命名冲突，
- 另外无法管理模块与模块之间的依赖关系

### State2-命名空间方式

每个模块只暴露一个全局对象，所有模块成员都挂载到这个对象中

**具体做法**

在第一阶段的基础上，通过将每个模块「包裹」为一个全局对象的形式实现，有点类似于为模块内的成员添加了「命名空间」的感觉。

```
// module a 相关状态数据和功能函数

var moduleA = {
  name: 'module-a',

  method1: function () {
    console.log(this.name + '#method1')
  },

  method2: function () {
    console.log(this.name + '#method2')
  }
}
```

**特点**

- 通过「命名空间」减小了命名冲突的可能，
- 但是同样没有私有空间，所有模块成员也可以在模块外部被访问或者修改，
- 而且也无法管理模块之间的依赖关系。

### State3-IIFE

使用立即执行函数表达式（IIFE：Immediately-Invoked Function Expression）为模块提供私有空间。

**具体做法**

将每个模块成员放在一个函数提供的私有作用域中，对于需要暴露给外部的成员，通过挂载到全局对象的方式实现

```
// module a 相关状态数据和功能函数

;(function () {
  var name = 'module-a'

  function method1 () {
    console.log(name + '#method1')
  }

  function method2 () {
    console.log(name + '#method2')
  }

  window.moduleA = {
    method1: method1,
    method2: method2
  }
})()

```

**特点**

- 有了私有成员的概念，私有成员只能在模块成员内通过闭包的形式访问。

上述做法就是我们模块化的基础，为了减少项目开发时的引用模块时造成的麻烦，提高开发效率，我们需要代码帮我们按照一定标准自动加载模块，此后模块化的标准逐渐形成，通行的 JavaScript 模块规范主要有三种：**CommonJS**、**AMD**、**ES Modules**

## CommonJS

CommonJS 是 nodejs 提出的一套规范，在 nodejs 中必须遵循这套规范。

**CommonJS 约定**

- 一个文件就是一个模块
- 每个模块都有单独的作用域
- 通过 module.exports 导出成员
- 通过 require 函数载入模块

来看下面代码：

```
//模块定义 myModel.js
var name = 'licop';

function consoleName(){
    console.log(name);
}

module.exports = {
    consoleName: consoleName
}

//加载模块
var nameModule = require('./myModel.js');
nameModule.consoleName();

```

CommonJS 是以**同步方式**加载模块，node 的执行机制是在启动时加载模块，在执行时是不需要加载的。但是在浏览器端使用每次页面加载都会导致大量的同步请求出现， 会导致效率低下。

## AMD

犹豫 Commonjs 规范在浏览器端的，所以在早期的前端的模块化规范并没有使用 CommonJS 规范，而是结合浏览器的特点设计了新的规范 AMD(Asynchronous Module Definition)。

`requirejs`实现了 AMD 规范，而且是一个强大的模块加载器。

```
// 使用define定义一个模块
// 第一个参数为模块的名字
// 第二个参数是一个数组用来声明模块的依赖项
// 第三个参数是一个函数，参数与前端依赖项一一对应，为当前某块提供私有的空间
define('module1', ['jquery', './module2'], function ($, module2) {
  return {
    start: function () {
      $('body').animate({ margin: '200px' })
      module2()
    }
  }
})

// 使用require载入一个模块
require(['./modules/module1'], function (module1) {
  module1.start()
})

```

当`requirejs`需要加载一个模块的话，会自动创建一个 script 标签，发送文件请求。

目前绝大多数第三方库都支持 AMD 规范。

但是 AMD 使用也有一些缺点：

- AMD 使用起来相对复杂
- 模块 js 文件请求频繁

## ES Modules

模块化最佳实践

- 浏览器端使用 ES Modules 规范
- nodejs 使用 CommonJS 规范
