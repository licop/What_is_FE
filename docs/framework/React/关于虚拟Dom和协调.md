# 关于虚拟 Dom 和协调

## 虚拟 Dom

**虚拟 DOM（Virtual DOM）** 是前端领域近几年比较出圈的一个概念，是相对于 HTML DOM（Document Object Model，文档对象模型）更轻量的 JS 模型。在 React、Vue.js、Elm 这样的声明式前端框架中，都包含了虚拟 DOM。

面向前端开发者，React 提供了包括 JSX 语法在内的声明组件 API，在运行时，开发者声明的组件会渲染成虚拟 DOM，虚拟 DOM 再由 React 框架渲染成真实的 DOM；虚拟 DOM 的变动，最终会自动体现在真实 DOM 上；真实 DOM 上的交互，也会由 React 框架抽象成虚拟 DOM 上的副作用（Side-effect），与开发者编写的交互逻辑关联起来。

**理想状态下，开发者在开发 React 应用时，可以完全不去接触真实 DOM**（但现实世界中这种情况很少见），一定程度上隐藏了 Web 原生技术的细节，有助于提高开发效率。

如下图所示，左半边展示了 React 面向开发者的 API，右半边则是 React 内部实现对 DOM API 的封装，渲染面向用户的页面：

![](/framework/react_dom_1.png)

### 真实 DOM 有什么问题？

React 的设计哲学 UI=f(state) ，理论上来说，对于给定的 f() 和状态数据，一定可以重现一模一样的 UI；这也意味着，**只要状态数据有变化，f()就需要重新执行，整个 UI 需要重新渲染。**

**操作真实 DOM 是比较耗费资源的**，无脑地大量调用 DOM API 绘制页面，页面很容易就卡了。

这时就需要 React 提供一系列算法和过程，过滤掉没有必要的 DOM API 调用，最终把 f() 的成本降下来。虚拟 DOM 就是这些算法过程的中间模型，它远比 DOM API 轻量，跟最终的 DOM API 分摊成本后，可以保证 React 组件的渲染效率。

虚拟 DOM 的价值在于，当你构建应用时，无需考虑状态的变化如何体现在 UI 上，且一般情况下不用担心性能问题。这减少了代码 Bug，比起乏味的编码，你可以把更多时间投入到创造性的工作上。

## 协调

React 组件会渲染出一棵元素树。因为开发者使用的是 React 的声明式 API，在此基础上，每次有 props、state 等数据变动时，组件会渲染出新的元素树，React 框架会与之前的树做 Diffing 对比，将元素的变动最终体现在浏览器页面的 DOM 中。这一过程就称为**协调（Reconciliation）**

## Diffing 算法

React 在以下两个假设的基础之上提出了一套 O(n) 的启发式算法：

- 两个不同类型的元素会产生出不同的树；
- 开发者可以使用 key 属性标识哪些子元素在不同的渲染中可能是不变的。

React 框架后续的版本中也在不断优化 Diffing 算法。近四年算法细节变了不少，但基本逻辑还是能归纳出以下几点：

1. 从根元素开始，React 将递归对比两棵树的根元素和子元素；
2. 对比不同类型的元素，如对比 HTML 元素和 React 组件元素，React 会直接清理旧的元素和它的子树，然后建立新的树；
3. 对比同为 HTML 元素，但 Tag 不同的元素，如从 `<a>`变成 `<div>` ，React 会直接清理旧的元素和子树，然后建立新的树；
4. 对比同为 React 组件元素，但组件类或组件函数不同的元素，如从 NewCard 变成 Card ，React 会卸载旧的元素和子树，然后挂载新的元素树；
5. 对比 Tag 相同的 HTML 元素，如 `<input type="text" value="old" />` 和 `<input type="text" value="new" />` ，React 将会保留该元素，并记录有改变的属性，在这个例子里就是 value 的值从 "old" 变成了 "new" ；
6. 对比组件类或组件函数相同的组件元素，如 `<Card title="老卡片" />` 和 `<Card title="新卡片" />` ，React 会保留组件实例，更新 props，并触发组件的生命周期方法或者 Hooks。

需要强调的是，在对比两棵树对应节点的子元素时，如果子元素形成一个列表，那么 React 会按顺序尝试匹配新旧两个列表的元素。

如果对比结果是在列表末尾新增或者减少元素那还好，但如果是在列表头部或者中间插入或者删除元素，React 就不知道该保留哪个元素了，干脆把整个列表都推翻了重建，这样会带来性能损耗。

为了应对这种情况，React 引入了 key 这个特殊属性，当有子元素列表中的元素有这个属性时，**React 会利用这个 key 属性值来匹配新旧列表中的元素**，以减少插入元素时的性能损耗。

这样的用途就要求在**任何一个子元素列表中，key 对于每个元素应该是唯一的且稳定的**。比如你的数据来自于数据库，包含了自增 ID，那么你就可以用这个 ID 当作 key 的值。

## 触发协调的场景

了解了什么是协调，以及协调对比算法的基本逻辑，我们再回到 React 应用开发者的视角，看一下开发者做什么事情时会触发协调。

首先，开发者在使用 React API 时，不应该随时想着协调的细节，否则会加重开发者的负担；但协调又是页面最终变化的必经之路，这在前面已经强调过。那么如果你是 React 框架的设计者，你会选择在什么情况下触发协调？一般而言你会有两个方向的选择，**拉（Pull）或者推（Push）**。

轮询（Polling）就是一种“拉”的方案，我们假设一个极端的设计，让 React 间隔每 16ms 触发一次协调，这从功能上是一定可以实现需求的，只要 React 元素树有风吹草动，这一次的协调就会算出 Diff，更新页面。但很容易就能看出这种方式的问题，也许元素树很长时间都没有变过，这会导致做了太多次没必要的协调，增加了资源的开销。

那么我们选择“推”的方案。我们要有方式告诉 React，说我们需要触发协调，而且这个方式应该停留在 React API 层面，否则会把协调这一内部过程的复杂性暴露给开发者。结合 React 的设计哲学，UI=f(state) （这个 state 泛指组件数据，不是 React 接口里哪个 state），我们认为只有数据变化时，才需要触发协调。

这就好办了，在 React API 里有哪些是操作组件数据的？是的， props 和 state ，除此之外再加一个 context。其中 props 从组件外面传进来，state 则是活跃在组件内部，至于 context ，在组件外面的 Context.Provider 提供数据，组件内部则可以消费 context 数据。

**只要这三种数据之一发生了变化，React 就会对当前组件触发协调过程，最终按照 Diffing 结果更改页面。**

> 注意：一个组件的 props 应该由父组件传进来，props 数据的变动也应该由父组件负责，不可以在自身组件的随意变更。

## Fiber 协调引擎

## 更多参考

- [协调 react 中文文档](https://zh-hans.reactjs.org/docs/reconciliation.html)
