{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[33],{399:function(e,n,r){\"use strict\";r.r(n);var t=r(27),s=Object(t.a)({},(function(){var e=this,n=e.$createElement,r=e._self._c||n;return r(\"ContentSlotsDistributor\",{attrs:{\"slot-key\":e.$parent.slotKey}},[r(\"h1\",{attrs:{id:\"promise-all-有哪些具体应用\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#promise-all-有哪些具体应用\"}},[e._v(\"#\")]),e._v(\" Promise.all()有哪些具体应用\")]),e._v(\" \"),r(\"p\",[r(\"strong\",[e._v(\"Promise.all(iterable)\")]),e._v(\" 方法返回一个 Promise 实例，此实例在 iterable 参数内所有的 promise 都“完成（resolved）”或参数中不包含 promise 时回调完成（resolve）；如果参数中 promise 有一个失败（rejected），此实例回调失败（reject），失败的原因是第一个失败 promise 的结果。\")]),e._v(\" \"),r(\"p\",[e._v(\"它通常在启动多个异步任务\"),r(\"strong\",[e._v(\"并发运行\")]),e._v(\"并为其结果创建承诺之后使用，以便人们可以等待所有任务完成。\")]),e._v(\" \"),r(\"h2\",{attrs:{id:\"参数\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#参数\"}},[e._v(\"#\")]),e._v(\" 参数\")]),e._v(\" \"),r(\"p\",[r(\"strong\",[e._v(\"iterable:\")]),e._v(\" 一个可迭代的对象，比如\"),r(\"strong\",[e._v(\"Array\")]),e._v(\"和\"),r(\"strong\",[e._v(\"String\")])]),e._v(\" \"),r(\"h2\",{attrs:{id:\"实现-promise-all\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#实现-promise-all\"}},[e._v(\"#\")]),e._v(\" 实现 promise.all\")]),e._v(\" \"),r(\"p\",[r(\"strong\",[e._v(\"核心思路\")])]),e._v(\" \"),r(\"ul\",[r(\"li\",[e._v(\"接收一个 Promise 实例的数组或具有 Iterator 接口的对象作为参数\")]),e._v(\" \"),r(\"li\",[e._v(\"这个方法返回一个新的 promise 对象，\")]),e._v(\" \"),r(\"li\",[e._v('遍历传入的参数，用 Promise.resolve()将参数\"包一层\"，使其变成一个 promise 对象')]),e._v(\" \"),r(\"li\",[e._v(\"参数所有回调成功才是成功，返回值数组与参数顺序一致\")]),e._v(\" \"),r(\"li\",[e._v(\"参数数组其中一个失败，则触发失败状态，第一个触发失败的 Promise 错误信息作为 Promise.all 的错误信息。\")])]),e._v(\" \"),r(\"div\",{staticClass:\"language- extra-class\"},[r(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[r(\"code\",[e._v(\"  // 实现promise.all\\nfunction promiseAll(promises) {\\n    return new Promise((resolve, reject) => {\\n        if(!Array.isArray(promises)) {\\n            throw new TypeError(`argument must be a array`)\\n        }\\n        let result = [];\\n        let count = 0;\\n        for(let i = 0; i < promises.length; i++) {\\n            Promise.resolve(promises[i]).then((value) => {\\n                count++\\n                result[i] = value;\\n                if(count === promises.length) {\\n                    resolve(result)\\n                }\\n            }, (error) => {\\n                return reject(error)\\n            })\\n        }\\n    })\\n}\\n\")])])]),r(\"h2\",{attrs:{id:\"应用场景-1-多个请求结果合并在一起\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#应用场景-1-多个请求结果合并在一起\"}},[e._v(\"#\")]),e._v(\" 应用场景 1：多个请求结果合并在一起\")]),e._v(\" \"),r(\"blockquote\",[r(\"p\",[e._v(\"具体描述：一个页面，有多个请求，我们需求所有的请求都返回数据后再一起处理渲染\")])]),e._v(\" \"),r(\"p\",[e._v(\"思考：如果并发请求的话，每个请求的 loading 状态要单独设置，多个的话可能多个 loading 重合，页面显示的内容 根据请求返回数据的快慢 有所差异，具体表现在渲染的过程，为提升用户体验，我们可以采用 所有请求返回数据后，再一起渲染，此时我们关闭请求的单独 loading 设置，通过 Promise.all 汇总请求结果，从开始到结束，我们只设置一个 loading 即可\")]),e._v(\" \"),r(\"div\",{staticClass:\"language- extra-class\"},[r(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[r(\"code\",[e._v(\"   //1.获取轮播数据列表\\nfunction getBannerList(){\\n    return new Promise((resolve,reject)=>{\\n        setTimeout(function(){\\n            resolve('轮播数据')\\n        },300)\\n    })\\n}\\n\\n//2.获取店铺列表\\nfunction getStoreList(){\\n   return new Promise((resolve,reject)=>{\\n        setTimeout(function(){\\n            resolve('店铺数据')\\n        },500)\\n    })\\n}\\n\\n//3.获取分类列表\\nfunction getCategoryList(){\\n   return new Promise((resolve,reject)=>{\\n        setTimeout(function(){\\n            resolve('分类数据')\\n        },700)\\n    })\\n}\\n\\nfunction initLoad() {\\n      // loading.show() //加载loading\\n    Promise.all([getBannerList(),getStoreList(),getCategoryList()]).then(res=>{\\n        console.log(res)\\n        // loading.hide() //关闭loading\\n    }).catch(err=>{\\n        console.log(err)\\n        // loading.hide()//关闭loading\\n    })\\n}\\n\\n//数据初始化\\ninitLoad()\\n\")])])]),r(\"h2\",{attrs:{id:\"应用场景-2-合并请求结果并处理错误\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#应用场景-2-合并请求结果并处理错误\"}},[e._v(\"#\")]),e._v(\" 应用场景 2：合并请求结果并处理错误\")]),e._v(\" \"),r(\"blockquote\",[r(\"p\",[e._v(\"描述：我们需求单独处理一个请求的数据渲染和错误处理逻辑，有多个请求，我们就需要在多个地方写\")])]),e._v(\" \"),r(\"p\",[e._v(\"思考：我们能否把多个请求合并在一起，哪怕有的请求失败了，也返回给我们，我们只需要在一个地方处理这些数据和错误的逻辑即可。\")]),e._v(\" \"),r(\"div\",{staticClass:\"language- extra-class\"},[r(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[r(\"code\",[e._v(\"   //1.获取轮播图数据列表\\nfunction getBannerList(){\\n    return new Promise((resolve,reject)=>{\\n        setTimeout(function(){\\n            // resolve('轮播图数据')\\n            reject('获取轮播图数据失败啦')\\n        },300)\\n    })\\n}\\n\\n//2.获取店铺列表\\nfunction getStoreList(){\\n   return new Promise((resolve,reject)=>{\\n        setTimeout(function(){\\n            resolve('店铺数据')\\n        },500)\\n    })\\n}\\n\\n//3.获取分类列表\\nfunction getCategoryList(){\\n    return new Promise((resolve,reject)=>{\\n        setTimeout(function(){\\n            resolve('分类数据')\\n        },700)\\n    })\\n}\\n\\nfunction initLoad(){\\n    // loading.show()\\n    Promise.all([\\n        getBannerList().catch(err=>err),\\n        getStoreList().catch(err=>err),\\n        getCategoryList().catch(err=>err)\\n    ]).then(res=>{\\n        console.log(res) // [\\\"获取轮播图数据失败啦\\\", \\\"店铺数据\\\", \\\"分类数据\\\"]\\n\\n        if(res[0] == '轮播图数据'){\\n            //渲染\\n        }else{\\n            //获取 轮播图数据 失败的逻辑\\n        }\\n        if(res[1] == '店铺数据'){\\n            //渲染\\n        }else{\\n            //获取 店铺列表数据 失败的逻辑\\n        }\\n        if(res[2] == '分类数据'){\\n            //渲染\\n        }else{\\n             //获取 分类列表数据 失败的逻辑\\n        }\\n\\n        // loading.hide()\\n    })\\n}\\n\\ninitLoad()\\n\\n\")])])]),r(\"p\",[e._v(\"有时候页面挂掉了，可能因为接口异常导致，或许只是一个无关紧要的接口挂掉了。那么一个接口挂掉了为什么会导致整个页面无数据呢？Promise.all 告诉我们，如果参数中 promise 有一个失败（rejected），此实例回调失败（reject），就不再执行 then 方法回调，以上用例 正好可以解决此种问题\")]),e._v(\" \"),r(\"h2\",{attrs:{id:\"应用场景-3-验证多个请求结果是否都是满足条件\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#应用场景-3-验证多个请求结果是否都是满足条件\"}},[e._v(\"#\")]),e._v(\" 应用场景 3：验证多个请求结果是否都是满足条件\")]),e._v(\" \"),r(\"blockquote\",[r(\"p\",[e._v(\"描述：在一个微信小程序项目中，做一个表单的输入内容安全验证，调用的是云函数写的方法，表单有多 7 个字段需要验证，都是调用的一个 内容安全校验接口，全部验证通过则 可以 进行正常的提交\")])]),e._v(\" \"),r(\"div\",{staticClass:\"language- extra-class\"},[r(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[r(\"code\",[e._v(\"  function verify1(content){\\n    return new Promise((resolve,reject)=>{\\n        setTimeout(function(){\\n            resolve(true)\\n        },200)\\n    })\\n}\\n\\nfunction verify2(content){\\n    return new Promise((resolve,reject)=>{\\n        setTimeout(function(){\\n            resolve(true)\\n        },700)\\n    })\\n}\\n\\nfunction verify3(content){\\n    return new Promise((resolve,reject)=>{\\n        setTimeout(function(){\\n            resolve(true)\\n        },300)\\n    })\\n}\\n\\nPromise.all([verify1('校验字段1的内容'),verify2('校验字段2的内容'),verify3('校验字段3的内容')]).then(result=>{\\n    console.log(result)//[true, true, true]\\n\\n    let verifyResult = result.every(item=>item)\\n    //验证结果\\n    console.log(verifyResult?'通过验证':'未通过验证')// 通过验证\\n}).catch(err=>{\\n    console.log(err)\\n})\\n\\n\")])])])])}),[],!1,null,null,null);n.default=s.exports}}]);","extractedComments":[]}