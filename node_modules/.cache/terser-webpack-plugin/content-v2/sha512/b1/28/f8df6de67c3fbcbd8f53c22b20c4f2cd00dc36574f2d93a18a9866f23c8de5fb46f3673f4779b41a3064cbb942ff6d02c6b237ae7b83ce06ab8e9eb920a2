{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[28],{395:function(n,e,a){\"use strict\";a.r(e);var t=a(27),r=Object(t.a)({},(function(){var n=this,e=n.$createElement,a=n._self._c||e;return a(\"ContentSlotsDistributor\",{attrs:{\"slot-key\":n.$parent.slotKey}},[a(\"h1\",{attrs:{id:\"函数式编程\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#函数式编程\"}},[n._v(\"#\")]),n._v(\" 函数式编程\")]),n._v(\" \"),a(\"h2\",{attrs:{id:\"为什么要学习函数式编程\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#为什么要学习函数式编程\"}},[n._v(\"#\")]),n._v(\" 为什么要学习函数式编程\")]),n._v(\" \"),a(\"ul\",[a(\"li\",[n._v(\"函数式编程是随着 React 的流行受到越来越多的关注\")]),n._v(\" \"),a(\"li\",[n._v(\"Vue 3 也开始拥抱函数式编程\")]),n._v(\" \"),a(\"li\",[n._v(\"函数式编程可以抛弃 \"),a(\"code\",[n._v(\"this\")])]),n._v(\" \"),a(\"li\",[n._v(\"打包过程中可以更好的利用 \"),a(\"code\",[n._v(\"tree shaking\")]),n._v(\" 过滤无用代码 方便测试、方便并行处理 有很多库可以帮助我们进行函数式开发:\"),a(\"code\",[n._v(\"lodash\")]),n._v(\"、\"),a(\"code\",[n._v(\"underscore\")]),n._v(\"、\"),a(\"code\",[n._v(\"ramda\")])])]),n._v(\" \"),a(\"h2\",{attrs:{id:\"什么是函数式编程\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#什么是函数式编程\"}},[n._v(\"#\")]),n._v(\" 什么是函数式编程\")]),n._v(\" \"),a(\"p\",[n._v(\"函数式编程(Functional Programming, FP)，FP 是编程范式之一，我们常听说的编程范式还有面向过程 编程、面向对象编程。\")]),n._v(\" \"),a(\"ul\",[a(\"li\",[n._v(\"面向对象编程的思维方式:把现实世界中的事物抽象成程序世界中的类和对象，通过封装、继承和 多态来演示事物事件的联系\")]),n._v(\" \"),a(\"li\",[n._v(\"函数式编程的思维方式:把现实世界的事物和事物之间的联系抽象到程序世界(对运算过程进行抽 象)\\n\"),a(\"ul\",[a(\"li\",[n._v(\"程序的本质:根据输入通过某种运算获得相应的输出，程序开发过程中会涉及很多有输入和 输出的函数\")]),n._v(\" \"),a(\"li\",[n._v(\"x -> f(联系、映射) -> y，y=f(x) 函数式编程中的函数指的不是程序中的函数(方法)，而是数学中的函数即映射关系，例如:y = sin(x)，x 和 y 的关系\")]),n._v(\" \"),a(\"li\",[n._v(\"相同的输入始终要得到相同的输出(纯函数) 函数式编程用来描述数据(函数)之间的映射\")])])])]),n._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[n._v(\"    // 非函数式\\n    let num1 = 2\\n    let num2 = 3\\n    let sum = num1 + num2 console.log(sum)\\n    // 函数式\\n    function add (n1, n2) {\\n    return n1 + n2\\n    }\\n    let sum = add(2, 3) console.log(sum)\\n\")])])]),a(\"h2\",{attrs:{id:\"前置知识\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#前置知识\"}},[n._v(\"#\")]),n._v(\" 前置知识\")]),n._v(\" \"),a(\"ul\",[a(\"li\",[n._v(\"函数是一等公民\")]),n._v(\" \"),a(\"li\",[n._v(\"高阶函数\")]),n._v(\" \"),a(\"li\",[n._v(\"闭包\")])]),n._v(\" \"),a(\"h3\",{attrs:{id:\"函数是一等公民\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#函数是一等公民\"}},[n._v(\"#\")]),n._v(\" 函数是一等公民\")]),n._v(\" \"),a(\"p\",[a(\"a\",{attrs:{href:\"https://developer.mozilla.org/zh-CN/docs/Glossary/First-class_Function\",target:\"_blank\",rel:\"noopener noreferrer\"}},[n._v(\"MDN First-class Function\"),a(\"OutboundLink\")],1)]),n._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",[a(\"code\",[n._v(\"- 函数可以存储在变量中\\n- 函数作为参数\\n- 函数作为返回值\\n\")])])]),a(\"p\",[n._v(\"在 JavaScript 中函数就是一个普通的对象 (可以通过 new Function() )，我们可以把函数存储到变量/ 数组中，它还可以作为另一个函数的参数和返回值，甚至我们可以在程序运行的时候通过来构造一个新的函数。\")]),n._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[n._v(\"  // 把函数赋值给变量\\nlet fn = function () {\\n    console.log('Hello First-class Function')\\n}\\nfn()\\n// 一个示例\\nconst BlogController = {\\n    index (posts) { return Views.index(posts) },\\n    show (post) { return Views.show(post) },\\n    create (attrs) { return Db.create(attrs) },\\n    update (post, attrs) { return Db.update(post, attrs) }, destroy (post) { return Db.destroy(post) }\\n}\\n// 优化\\nconst BlogController = {\\n    index: Views.index,\\n    show: Views.show,\\n    create: Db.create,\\n    update: Db.update,\\n    destroy: Db.destroy\\n}\\n\\n\")])])]),a(\"p\",[n._v(\"函数是一等公民是高阶函数、柯里化等的基础。\")]),n._v(\" \"),a(\"h3\",{attrs:{id:\"高阶函数-higher-order-function\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#高阶函数-higher-order-function\"}},[n._v(\"#\")]),n._v(\" 高阶函数(Higher-order function)\")]),n._v(\" \"),a(\"h4\",{attrs:{id:\"什么是高阶函数\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#什么是高阶函数\"}},[n._v(\"#\")]),n._v(\" 什么是高阶函数\")]),n._v(\" \"),a(\"ul\",[a(\"li\",[n._v(\"可以把函数作为参数传递给另一个函数\")]),n._v(\" \"),a(\"li\",[n._v(\"可以把函数作为另一个函数的返回结果 函数作为参数\")])]),n._v(\" \"),a(\"h4\",{attrs:{id:\"函数作为参数\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#函数作为参数\"}},[n._v(\"#\")]),n._v(\" 函数作为参数\")]),n._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[n._v(\"  // forEach\\nfunction forEach(array, fn) {\\n    for(let i = 0; i < array.length; i++) {\\n        fn(array[i])\\n    }\\n}\\n// filter\\nfunction filter(array, fn) {\\n    let results = []\\n    for(let i = 0; i < array.length; i++) {\\n        if(fn(array[i])) {\\n            results.push(array[i])\\n        }\\n    }\\n    return results;\\n}\\n\")])])]),a(\"h4\",{attrs:{id:\"函数作为返回值\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#函数作为返回值\"}},[n._v(\"#\")]),n._v(\" 函数作为返回值\")]),n._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[n._v(\"function once(fn) {\\n    let done = false;\\n\\n    return function() {\\n        if(!done) {\\n            done = true;\\n            return fn.apply(this, arguments)\\n        }\\n    }\\n}\\nlet pay = once(function (money) {\\n    console.log(`支付： ${money} RMB`);\\n})\\n\\npay(5)\\npay(6)\\n\\n\")])])]),a(\"h3\",{attrs:{id:\"使用高阶函数的意义\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#使用高阶函数的意义\"}},[n._v(\"#\")]),n._v(\" 使用高阶函数的意义\")]),n._v(\" \"),a(\"ul\",[a(\"li\",[n._v(\"抽象可以帮我们屏蔽细节，只需要关注与我们的目标\")]),n._v(\" \"),a(\"li\",[n._v(\"高阶函数是用来抽象通用的问题\")])]),n._v(\" \"),a(\"h3\",{attrs:{id:\"常用高阶函数\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#常用高阶函数\"}},[n._v(\"#\")]),n._v(\" 常用高阶函数\")]),n._v(\" \"),a(\"ul\",[a(\"li\",[n._v(\"map\")]),n._v(\" \"),a(\"li\",[n._v(\"filter\")]),n._v(\" \"),a(\"li\",[n._v(\"every\")]),n._v(\" \"),a(\"li\",[n._v(\"some\")]),n._v(\" \"),a(\"li\",[n._v(\"find/findIndex\")]),n._v(\" \"),a(\"li\",[n._v(\"reduce\")]),n._v(\" \"),a(\"li\",[n._v(\"sort\")])]),n._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[n._v(\"// map\\nconst map = (array, fn) => {\\n    let result = [];\\n    for(let value of array) {\\n        result.push(fn(value))\\n    }\\n    return result;\\n}\\n\\n// every\\nconst every = (array, fn) => {\\n    let result = true\\n    for(let value of array) {\\n        result = fn(value)\\n        if(!result) {\\n            break;\\n        }\\n    }\\n    return result;\\n}\\n\\n// some\\nconst some = (array, fn) => {\\n    let result = false\\n    for(let value of array) {\\n        result = fn(value)\\n        if(result) {\\n            break\\n        }\\n    }\\n    return result;\\n}\\n\\n// find\\nconst find = (array, fn) => {\\n    let result = undefined;\\n    for(let value of array) {\\n        if(fn(value)) {\\n            result = value\\n            break;\\n        }\\n    }\\n    return result;\\n}\\n// findIndex\\nconst findIndex = (array, fn) => {\\n    let result = -1;\\n    for(let i = 0; i < array.length; i++) {\\n        if(fn(array[i])) {\\n            result = i;\\n            break;\\n        }\\n    }\\n    return result\\n}\\n\\n// reduce\\nconst reduce = (array, fn, init) => {\\n    const result = init;\\n    let i = 0;\\n    if(result === undefined) {\\n        result = array[0]\\n        i = 1\\n    }\\n\\n    for(i; i < array.length; i++) {\\n        result = fn(result, array[i], i, array)\\n    }\\n    return result;\\n}\\n\\n// sort\\n// 冒泡实现\\nconst sort = (array, fn) => {\\n    for(let i = 0; i < array.length - 1; i++) {\\n        for(let j = 1; j < array.length; j++) {\\n            if(fn(array[j], array[j + 1])) {\\n                const element = arr[j];\\n                arr[j] = arr[j+1];\\n                arr[j+1] = element\\n            }\\n        }\\n    }\\n}\\n\")])])]),a(\"h3\",{attrs:{id:\"闭包\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#闭包\"}},[n._v(\"#\")]),n._v(\" 闭包\")]),n._v(\" \"),a(\"ul\",[a(\"li\",[n._v(\"闭包(closure): 函数和其周围的状态(词法环境)的引用捆绑在一起形成闭包\\n\"),a(\"ul\",[a(\"li\",[n._v(\"可以在另一个作用域中调用一个函数的内部函数并访问到该函数的作用域中的成员，延长了外部函数内部变量的作用范围\")])])]),n._v(\" \"),a(\"li\",[n._v(\"闭包的本质:函数在执行的时候会放到一个执行栈上当函数执行完毕之后会从执行栈上移除，但是 堆上的作用域成员因为被外部引用不能释放，因此内部函数依然可以访问外部函数的成员\")]),n._v(\" \"),a(\"li\",[n._v(\"闭包案例\")])]),n._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[n._v(\"    // 生成计算数字的多少次幂的函数\\n    function makePower(power) {\\n        return function (number) {\\n            return Math.pow(number, power);\\n        }\\n    }\\n\\n    let power2 = makePower(2)\\n    let power3 = makePower(3)\\n\\n\")])])]),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[n._v(\"   // 计算工资，基本工资+绩效工资\\n    function makeSalary(base) {\\n        return function(performance) {\\n            return base + performance;\\n        }\\n    }\\n\\n    let salaryLevel1 = makeSalary(12000)\\n    let salaryLevel2 = makeSalary(15000)\\n\")])])]),a(\"h2\",{attrs:{id:\"纯函数\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#纯函数\"}},[n._v(\"#\")]),n._v(\" 纯函数\")]),n._v(\" \"),a(\"h3\",{attrs:{id:\"纯函数概念\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#纯函数概念\"}},[n._v(\"#\")]),n._v(\" 纯函数概念\")]),n._v(\" \"),a(\"ul\",[a(\"li\",[a(\"p\",[n._v(\"纯函数: \"),a(\"strong\",[n._v(\"相同的输入永远会得到相同的输出\")]),n._v(\"，而且没有任何可观察的副作用\")]),n._v(\" \"),a(\"ul\",[a(\"li\",[n._v(\"纯函数就类似数学中的函数(用来描述输入和输出之间的关系)，y = f(x)\")])])]),n._v(\" \"),a(\"li\",[a(\"p\",[a(\"code\",[n._v(\"lodash\")]),n._v(\" 是一个纯函数的功能库，提供了对数组、数字、对象、字符串、函数等操作的一些方法\")])]),n._v(\" \"),a(\"li\",[a(\"p\",[n._v(\"数组的 slice 和 splice 分别是:纯函数和不纯的函数\")]),n._v(\" \"),a(\"ul\",[a(\"li\",[n._v(\"slice 返回数组中的指定部分，不会改变原数组 splice\")]),n._v(\" \"),a(\"li\",[n._v(\"对数组进行操作返回该数组，会改变原数组\")])])])]),n._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[n._v(\"  let numbers = [1, 2, 3, 4, 5]\\n\\n  // 纯函数\\n  numbers.slice(0, 3)\\n  // => [1, 2, 3]\\n  numbers.slice(0, 3)\\n  // => [1, 2, 3]\\n  numbers.slice(0, 3)\\n  // => [1, 2, 3]\\n\\n  // 不纯的函数\\n  numbers.splice(0, 3)\\n  // => [1, 2, 3]\\n  numbers.splice(0, 3)\\n  // => [4, 5]\\n  numbers.splice(0, 3)\\n\")])])]),a(\"ul\",[a(\"li\",[n._v(\"函数式编程不会保留计算中间的结果，所以变量是不可变的(无状态的)\")]),n._v(\" \"),a(\"li\",[n._v(\"我们可以把一个函数的执行结果交给另一个函数去处理\")])]),n._v(\" \"),a(\"h3\",{attrs:{id:\"纯函数的好处\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#纯函数的好处\"}},[n._v(\"#\")]),n._v(\" 纯函数的好处\")]),n._v(\" \"),a(\"ul\",[a(\"li\",[n._v(\"可缓存 因为纯函数对相同的输入始终有相同的结果，所以可以把纯函数的结果缓存起来\")])]),n._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[n._v(\" const _ = require('lodash')\\n function getArea (r) { return Math.PI * r * r }\\n let getAreaWithMemory = _.memoize(getArea) console.log(getAreaWithMemory(4))\\n\")])])]),a(\"ul\",[a(\"li\",[n._v(\"自己模拟一个 \"),a(\"strong\",[n._v(\"memoize\")]),n._v(\" 函数\")])]),n._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[n._v(\"function memoize(fn) {\\n    let cache = {};\\n\\n    return function () {\\n        let key = JSON.stringify(arguments);\\n        cache[key] = cache[key] || fn.apply(fn, arguments);\\n\\n        return cache[key]\\n    }\\n}\\n\")])])]),a(\"ul\",[a(\"li\",[n._v(\"可测试 纯函数让测试更方便\")]),n._v(\" \"),a(\"li\",[n._v(\"并行处理\\n\"),a(\"ul\",[a(\"li\",[n._v(\"在多线程环境下并行操作共享的内存数据很可能会出现意外情况\")]),n._v(\" \"),a(\"li\",[n._v(\"纯函数不需要访问共享的内存数据，所以在并行环境下可以任意运行纯函数 (Web Worker)\")])])])]),n._v(\" \"),a(\"h3\",{attrs:{id:\"副作用\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#副作用\"}},[n._v(\"#\")]),n._v(\" 副作用\")]),n._v(\" \"),a(\"ul\",[a(\"li\",[n._v(\"纯函数:对于相同的输入永远会得到相同的输出，而且没有任何可观察的\"),a(\"strong\",[n._v(\"副作用\")])])]),n._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[n._v(\"    // 不纯的\\n    let mini = 18\\n    function checkAge (age) {\\n    return age >= mini\\n    }\\n    // 纯的(有硬编码，后续可以通过柯里化解决) function checkAge (age) {\\n    let mini = 18\\n    return age >= mini\\n    }\\n\")])])]),a(\"p\",[n._v(\"副作用让一个函数变的不纯(如上例)，纯函数的根据相同的输入返回相同的输出，如果函数依赖于外部 的状态就无法保证输出相同，就会带来副作用。\")]),n._v(\" \"),a(\"p\",[n._v(\"副作用来源:\")]),n._v(\" \"),a(\"ul\",[a(\"li\",[n._v(\"配置文件\")]),n._v(\" \"),a(\"li\",[n._v(\"数据库\")]),n._v(\" \"),a(\"li\",[n._v(\"获取用户的输入 ......\")])]),n._v(\" \"),a(\"p\",[n._v(\"所有的外部交互都有可能带来副作用，副作用也使得方法通用性下降不适合扩展和可重用性，同时副作 用会给程序中带来安全隐患给程序带来不确定性，但是副作用不可能完全禁止，尽可能控制它们在可控 范围内发生。\")]),n._v(\" \"),a(\"h2\",{attrs:{id:\"柯里化-haskell-brooks-curry\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#柯里化-haskell-brooks-curry\"}},[n._v(\"#\")]),n._v(\" 柯里化 (Haskell Brooks Curry)\")]),n._v(\" \"),a(\"ul\",[a(\"li\",[n._v(\"使用柯里化解决上一个案例中硬编码的问题\")])]),n._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[n._v(\"    function checkAge (age) { let min = 18\\n        return age >= min\\n    }\\n    // 普通纯函数\\n    function checkAge (min, age) {\\n        return age >= min\\n    }\\n    checkAge(18, 24)\\n    checkAge(18, 20)\\n    checkAge(20, 30)\\n\\n    // 柯里化\\n    function checkAge (min) {\\n        return function (age) {\\n            return age >= min\\n        }\\n    }\\n\\n    // ES6 写法\\n    let checkAge = min => (age => age >= min)\\n    let checkAge18 = checkAge(18)\\n    let checkAge20 = checkAge(20)\\n\\n    checkAge18(24)\\n    checkAge18(20)\\n\")])])]),a(\"ul\",[a(\"li\",[n._v(\"当一个函数有多个参数的时候先传递一部分参数调用它(这部分参数以后永远不变)\")]),n._v(\" \"),a(\"li\",[n._v(\"然后返回一个新的函数接收剩余的参数，返回结果\")])]),n._v(\" \"),a(\"h3\",{attrs:{id:\"lodash-中的柯里化函数\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#lodash-中的柯里化函数\"}},[n._v(\"#\")]),n._v(\" lodash 中的柯里化函数\")]),n._v(\" \"),a(\"ul\",[a(\"li\",[n._v(\"_.curry(func)\\n\"),a(\"ul\",[a(\"li\",[n._v(\"功能:创建一个函数，该函数接收一个或多个 func 的参数，如果 func 所需要的参数都被提 供则执行 func 并返回执行的结果。否则继续返回该函数并等待接收剩余的参数。\")]),n._v(\" \"),a(\"li\",[n._v(\"参数:需要柯里化的函数\")]),n._v(\" \"),a(\"li\",[n._v(\"返回值:柯里化后的函数\")])])])]),n._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[n._v(\"    const _ = require('lodash') // 要柯里化的函数\\n    function getSum (a, b, c) {\\n    return a + b + c\\n    }\\n    // 柯里化后的函数\\n    let curried = _.curry(getSum) // 测试\\n    curried(1, 2, 3) curried(1)(2)(3)\\n    curried(1, 2)(3)\\n\")])])]),a(\"ul\",[a(\"li\",[n._v(\"案例\")])]),n._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[n._v(\"    const _ = require('lodash')\\n    const match = _.curry(function (reg, str) {\\n        return str.match(reg)\\n    })\\n    const haveSpace = match(/\\\\s+/g)\\n    const haveNumber = match(/\\\\d+/g)\\n\\n    console.log(haveSpace('hello world'))\\n    console.log(haveNumber('25$'))\\n\\n    const filter = _.curry(function (func, array) {\\n        return array.filter(func)\\n    })\\n    console.log(filter(haveSpace, ['John Connor', 'John_Donne']))\\n\\n    const findSpace = filter(haveSpace)\\n    console.log(findSpace(['John Connor', 'John_Donne']))\\n\")])])]),a(\"p\",[n._v(\"模拟 _.curry() 的实现\")]),n._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[n._v(\"function curry(fn) {\\n    return function curriedFn(...args) {\\n        // 判断实参和形参的个数\\n        if(args.length < fn.length) {\\n            return function () {\\n                return curriedFn(...args.concat(Array.from(arguments)));\\n            }\\n        }\\n        return fn(...args);\\n\\n    }\\n}\\n\")])])]),a(\"h3\",{attrs:{id:\"总结\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#总结\"}},[n._v(\"#\")]),n._v(\" 总结\")]),n._v(\" \"),a(\"ul\",[a(\"li\",[n._v(\"柯里化可以让我们给一个函数传递较少的参数得到一个已经记住了某些固定参数的新函数\")]),n._v(\" \"),a(\"li\",[n._v(\"这是一种对函数参数的'缓存'\")]),n._v(\" \"),a(\"li\",[n._v(\"让函数变的更灵活，让函数的粒度更小 可以把多元函数转换成一元函数，可以组合使用函数产生强大的功能\")])]),n._v(\" \"),a(\"h2\",{attrs:{id:\"函数组合\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#函数组合\"}},[n._v(\"#\")]),n._v(\" 函数组合\")]),n._v(\" \"),a(\"ul\",[a(\"li\",[n._v(\"纯函数和柯里化很容易写出洋葱代码 h(g(f(x)))\\n\"),a(\"ul\",[a(\"li\",[n._v(\"获取数组的最后一个元素再转换成大写字母， \"),a(\"em\",[n._v(\".toUpper(\")]),n._v(\".first(_.reverse(array)))\")])])]),n._v(\" \"),a(\"li\",[n._v(\"函数组合可以让我们把细粒度的函数重新组合生成一个新的函数\")])]),n._v(\" \"),a(\"h3\",{attrs:{id:\"管道\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#管道\"}},[n._v(\"#\")]),n._v(\" 管道\")]),n._v(\" \"),a(\"p\",[n._v(\"下面这张图表示程序中使用函数处理数据的过程，给 fn 函数输入参数 a，返回结果 b。可以想想 a 数据 通过一个管道得到了 b 数据。\")]),n._v(\" \"),a(\"p\",[a(\"img\",{attrs:{src:\"/programming-basics/pipe.png\",alt:\"\"}})]),n._v(\" \"),a(\"p\",[n._v(\"当 fn 函数比较复杂的时候，我们可以把函数 fn 拆分成多个小函数，此时多了中间运算过程产生的 m 和 n。\")]),n._v(\" \"),a(\"p\",[n._v(\"下面这张图中可以想象成把 fn 这个管道拆分成了 3 个管道 f1, f2, f3，数据 a 通过管道 f3 得到结果 m，m 再通过管道 f2 得到结果 n，n 通过管道 f1 得到最终结果 b。\")]),n._v(\" \"),a(\"p\",[a(\"img\",{attrs:{src:\"/programming-basics/pipe2.png\",alt:\"\"}})]),n._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[n._v(\"  fn=compose(f1,f2,f3)\\n  b=fn(a)\\n\")])])]),a(\"h3\",{attrs:{id:\"函数组合-2\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#函数组合-2\"}},[n._v(\"#\")]),n._v(\" 函数组合\")]),n._v(\" \"),a(\"p\",[n._v(\"函数组合 (compose):如果一个函数要经过多个函数处理才能得到最终值，这个时候可以把中间 过程的函数合并成一个函数\")]),n._v(\" \"),a(\"ul\",[a(\"li\",[n._v(\"函数就像是数据的管道，函数组合就是把这些管道连接起来，让数据穿过多个管道形成最终结果\")]),n._v(\" \"),a(\"li\",[a(\"strong\",[n._v(\"函数组合默认是从右到左执行\")])])]),n._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[n._v(\"    // 组合函数\\n    function compose (f, g) {\\n        return function (x) {\\n            return f(g(x))\\n        }\\n    }\\n    function first (arr) {\\n        return arr[0]\\n    }\\n    function reverse (arr) {\\n        return arr.reverse()\\n    }\\n    // 从右到左运行\\n    let last = compose(first, reverse)\\n    console.log(last([1, 2, 3, 4]))\\n\")])])]),a(\"h3\",{attrs:{id:\"lodash-中的组合函数\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#lodash-中的组合函数\"}},[n._v(\"#\")]),n._v(\" lodash 中的组合函数\")]),n._v(\" \"),a(\"ul\",[a(\"li\",[n._v(\"lodash 中组合函数 flow() 或者 flowRight()，他们都可以组合多个函数\")]),n._v(\" \"),a(\"li\",[n._v(\"flow() 是从左到右运行\")]),n._v(\" \"),a(\"li\",[n._v(\"flowRight() 是从右到左运行，使用的更多一些\")])]),n._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[n._v(\"    // lodash 中的函数组合的方法 _.flowRight()\\n    const _ = require('lodash');\\n    const reverse = arr => arr.reverse();\\n    const first = arr => arr[0];\\n    const toUpper = s => s.toUpperCase();\\n\\n    const f = _.flowRight(toUpper, first, reverse);\\n    console.log(f(['one', 'two', 'three']));\\n\\n\")])])]),a(\"ul\",[a(\"li\",[n._v(\"模拟实现 lodash 的 flowRight 方法\")])]),n._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[n._v(\"function compose(...args) {\\n    return function(value) {\\n        return args.reverse().reduce(function(acc, fn) {\\n            return fn(acc);\\n        }, value)\\n    }\\n}\\n// es6\\nconst compose = (...args) => value => args.reverse().reduce((acc, fn) => fn(acc), value);\\n\")])])]),a(\"h3\",{attrs:{id:\"调试\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#调试\"}},[n._v(\"#\")]),n._v(\" 调试\")]),n._v(\" \"),a(\"ul\",[a(\"li\",[n._v(\"如何调试组合函数\")])]),n._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[n._v(\"    // 函数组合 调试\\n    // NEVER SAY DIE  --\\x3e never-say-die\\n\\n    const _ = require('lodash')\\n\\n    const trace = _.curry((tag, v) => {\\n        console.log(tag, v)\\n        return v\\n    })\\n\\n    // _.split()\\n    const split = _.curry((sep, str) => _.split(str, sep))\\n\\n    // _.toLower()\\n    const join = _.curry((sep, array) => _.join(array, sep))\\n\\n    const map = _.curry((fn, array) => _.map(array, fn))\\n\\n    const f = _.flowRight(join('-'), trace('map 之后'), map(_.toLower), trace('split 之后'), split(' '))\\n\\n    console.log(f('NEVER SAY DIE'))\\n\")])])]),a(\"h3\",{attrs:{id:\"lodash-fp\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#lodash-fp\"}},[n._v(\"#\")]),n._v(\" lodash/fp\")]),n._v(\" \"),a(\"ul\",[a(\"li\",[n._v(\"lodash 的 fp 模块提供了实用的对函数式编程友好的方法 \"),a(\"a\",{attrs:{href:\"https://github.com/lodash/lodash/wiki/FP-Guide\",target:\"_blank\",rel:\"noopener noreferrer\"}},[n._v(\"lodash/fp\"),a(\"OutboundLink\")],1)]),n._v(\" \"),a(\"li\",[n._v(\"提供了不可变 auto-curried iteratee-first data-last 的方法\")])]),n._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[n._v(\"// lodash 模块\\nconst _ = require('lodash')\\n\\n_.map(['a', 'b', 'c'], _.toUpper)\\n// => ['A', 'B', 'C']\\n_.map(['a', 'b', 'c'])\\n// => ['a', 'b', 'c']\\n\\n_.split('Hello World', ' ')\\n\\n// lodash/fp 模块\\nconst fp = require('lodash/fp')\\n\\nfp.map(fp.toUpper, ['a', 'b', 'c'])\\nfp.map(fp.toUpper)(['a', 'b', 'c'])\\n\\nfp.split(' ', 'Hello World')\\nfp.split(' ')('Hello World')\\n\")])])]),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[n._v(\"// NEVER SAY DIE  --\\x3e never-say-die\\n\\nconst fp = require('lodash/fp');\\n\\nconst f = fp.flowRight(fp.join('-'), fp.map(fp.toLower), fp.split(' '));\\n\\nconsole.log(f('NEVER SAY DIE'));\\n\\n\")])])]),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[n._v(\"// lodash 和 lodash/fp 模块中map方法的区别\\nconst _ = require('lodash');\\nconsole.log(_.map(['23', '8', '10', '12'], parseInt)); // [ 23, NaN, 2 ]\\n\\n// parseInt('23', 0, array);\\n// parserInt('8', 1, array)\\n// parserInt('10', 2, array)\\n\\n// fp.map只给函数传递一个参数\\nconst fp = require('lodash/fp');\\nconsole.log(fp.map(parseInt)(['23', '8', '10'])) // [23, 8, 10]\\n\\n\")])])]),a(\"h3\",{attrs:{id:\"point-free\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#point-free\"}},[n._v(\"#\")]),n._v(\" Point Free\")]),n._v(\" \"),a(\"p\",[a(\"strong\",[n._v(\"Point Free\")]),n._v(\": 我们可以把数据处理的过程定义成与数据无关的合成运算，不需要用到代表数据的那个参\\n数，只要把简单的运算步骤合成到一起，在使用这种模式之前我们需要定义一些辅助的基本运算函数。\")]),n._v(\" \"),a(\"ul\",[a(\"li\",[n._v(\"不需要指明处理的数据\")]),n._v(\" \"),a(\"li\",[n._v(\"只需要合成运算过程\")]),n._v(\" \"),a(\"li\",[n._v(\"需要定义一些辅助的基本运算函数\")])]),n._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[n._v(\"// Hello   World => hello_world\\n\\nconst fp = require('lodash/fp');\\nconst f = fp.flowRight(fp.replace(/\\\\s+/g, '_'), fp.toLower);\\n\\nconsole.log(f('Hello   World'))\\n\")])])]),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[n._v(\"// 把一个字符串中的首字母提取并转换成大写, 使用. 作为分隔符\\n// world wild web ==> W. W. W\\nconst fp = require('lodash/fp')\\n\\n// const firstLetterToUpper = fp.flowRight(fp.join('. '), fp.map(fp.first), fp.map(fp.toUpper), fp.split(' '))\\nconst firstLetterToUpper = fp.flowRight(fp.join('. '), fp.map(fp.flowRight(fp.first, fp.toUpper)), fp.split(' '))\\n\\nconsole.log(firstLetterToUpper('world wild web'))\\n\")])])]),a(\"h2\",{attrs:{id:\"函子-functor\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#函子-functor\"}},[n._v(\"#\")]),n._v(\" 函子（Functor）\")]),n._v(\" \"),a(\"h3\",{attrs:{id:\"为什么要学函子\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#为什么要学函子\"}},[n._v(\"#\")]),n._v(\" 为什么要学函子\")]),n._v(\" \"),a(\"p\",[n._v(\"到目前为止已经已经学习了函数式编程的一些基础，但是我们还没有演示在函数式编程中如何把副作用 控制在可控的范围内、异常处理、异步操作等。\")]),n._v(\" \"),a(\"h3\",{attrs:{id:\"副作用-side-effects\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#副作用-side-effects\"}},[n._v(\"#\")]),n._v(\" 副作用（side-effects）\")]),n._v(\" \"),a(\"p\",[n._v(\"说得直白一点就是与程序外部的世界的交互作用，比如改变显示屏的界面展示，读写后端数据库中的内容，副作用让我们的应用得以与外部世界发生交互以实现功能。如果一段代码完全没有副作用，那执行完以后你只会发现电脑热了一点（这其实也是一种副作用）。所以可以说，程序的价值就在于它产生的副作用。\")]),n._v(\" \"),a(\"p\",[n._v(\"然而在开发阶段，由于外部世界的不可控性（例如没有办法控制后端返回的数据，没有办法控制用户浏览器的缓存数据等等），包含副作用的逻辑行为往往也跟着变得不可预测。\")]),n._v(\" \"),a(\"p\",[n._v(\"当一个应用充斥着副作用，我们将难以确定我们写完的逻辑哪些是可靠的哪些是有漏洞的，难以定位一个错误来自哪里，难以通过有限的 mock 工作，来完全模拟代码的外部世界。\")]),n._v(\" \"),a(\"p\",[n._v(\"函数式编程提倡把副作用分离出来，让没有副作用的“纯”逻辑们待在一起，远离包含副作用的逻辑。\")]),n._v(\" \"),a(\"h3\",{attrs:{id:\"什么是-functor\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#什么是-functor\"}},[n._v(\"#\")]),n._v(\" 什么是 Functor\")]),n._v(\" \"),a(\"ul\",[a(\"li\",[n._v(\"容器:包含值和值的变形关系(这个变形关系就是函数)\")]),n._v(\" \"),a(\"li\",[n._v(\"函子:是一个特殊的容器，通过一个普通的对象来实现，该对象具有 map 方法，map 方法可以运 行一个函数对值进行处理(变形关系)\")])]),n._v(\" \"),a(\"h3\",{attrs:{id:\"functor-函子\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#functor-函子\"}},[n._v(\"#\")]),n._v(\" Functor 函子\")]),n._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[n._v(\"// 一个容器，包裹一个值\\nclass Container {\\n    // of 静态方法，可以省略 new 关键字创建对象\\n    static of (value) {\\n        return new Container(value)\\n    }\\n\\n\\n    constructor(value) {\\n        this._value = value\\n    }\\n\\n    // map 方法，传入变形关系，将容器里的每一个值映射到另一个容器\\n    map(fn) {\\n        return Container.of(fn(this._value))\\n    }\\n}\\n\\nlet r = Container.of(5)\\n    .map(x => x + 2)\\n    .map(x => x * x)\\n\\nconsole.log(r);\\n\")])])]),a(\"ul\",[a(\"li\",[a(\"p\",[n._v(\"总结\")]),n._v(\" \"),a(\"ul\",[a(\"li\",[n._v(\"函数式编程的运算不直接操作值，而是由函子完成\")]),n._v(\" \"),a(\"li\",[n._v(\"函子就是一个实现了 map 契约的对象\")]),n._v(\" \"),a(\"li\",[n._v(\"我们可以把函子想象成一个盒子，这个盒子里封装了一个值\")]),n._v(\" \"),a(\"li\",[n._v(\"想要处理盒子中的值，我们需要给盒子的 map 方法传递一个处理值的函数(纯函数)，由这 个函数来对值进行处理\")]),n._v(\" \"),a(\"li\",[n._v(\"最终 map 方法返回一个包含新值的盒子(函子)\")])])]),n._v(\" \"),a(\"li\",[a(\"p\",[n._v(\"在 Functor 中如果我们传入 null 或 undefined\")])])]),n._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[n._v(\"  // 值如果不小心传入了空值(副作用) Container.of(null)\\n  .map(x => x.toUpperCase())\\n  // TypeError: Cannot read property 'toUpperCase' of null\\n\")])])]),a(\"h3\",{attrs:{id:\"maybe-函子\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#maybe-函子\"}},[n._v(\"#\")]),n._v(\" MayBe 函子\")]),n._v(\" \"),a(\"ul\",[a(\"li\",[n._v(\"我们在编程的过程中可能会遇到很多错误，需要对这些错误做相应的处理\")]),n._v(\" \"),a(\"li\",[n._v(\"MayBe 函子的作用就是可以对外部的空值情况做处理(控制副作用在允许的范围)\")])]),n._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[n._v(\" // MayBe函子\\nclass MayBe {\\n    static of(value) {\\n        return new MayBe(value);\\n    }\\n\\n    constructor(value) {\\n        this._value = value;\\n    }\\n\\n    map(fn) {\\n        return this.isNothing() ? MayBe.of(null) : MayBe.of(fn(this._value))\\n    }\\n\\n    isNothing() {\\n        return this._value === undefined || this._value === null\\n    }\\n}\\n\\nlet r = MayBe.of('Hello world')\\n      .map(x => x.toUpperCase())\\n      .map(x => null)\\n      .map(x => x.split(' '))\\nconsole.log(r)\\n\\n\")])])]),a(\"h3\",{attrs:{id:\"either-函子\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#either-函子\"}},[n._v(\"#\")]),n._v(\" Either 函子\")]),n._v(\" \"),a(\"ul\",[a(\"li\",[n._v(\"Either 两者中的任何一个，类似于 if...else...的处理\")]),n._v(\" \"),a(\"li\",[n._v(\"异常会让函数变的不纯，Either 函子可以用来做异常处理\")])]),n._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[n._v(\"\\n  // Either 函子\\nclass Left {\\n    static of(value) {\\n        return new Left(value)\\n    }\\n    constructor(value) {\\n        this._value = value\\n    }\\n\\n    map(fn) {\\n        return this\\n    }\\n}\\n\\nclass Right {\\n    static of(value) {\\n        return new Right(value)\\n    }\\n    constructor(value) {\\n        this._value = value\\n    }\\n    map(fn) {\\n        return Right.of(fn(this._value));\\n    }\\n}\\n\\nlet r1 = Right.of(12).map(x => x + 2);\\nlet r2 = Left.of(12).map(x => x + 2);\\n\\n// console.log(r1);\\n// console.log(r2);\\n\\nfunction parseJSON(str) {\\n    try{\\n        return Right.of(JSON.parse(str));\\n    } catch(e) {\\n        return Left.of({error: e.message})\\n    }\\n}\\n// let r3 = parseJSON('{name: zs}');\\n// console.log(r3);\\n\\nlet r3 = parseJSON('{\\\"name\\\": \\\"zs\\\"}')\\n            .map(x => x.name.toUpperCase());\\nconsole.log(r3);\\n\")])])]),a(\"h3\",{attrs:{id:\"io-函子\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#io-函子\"}},[n._v(\"#\")]),n._v(\" IO 函子\")]),n._v(\" \"),a(\"ul\",[a(\"li\",[n._v(\"IO 函子中的 _value 是一个函数，这里是把函数作为值来处理\")]),n._v(\" \"),a(\"li\",[n._v(\"IO 函子可以把不纯的动作存储到 _value 中，延迟执行这个不纯的操作(惰性执行)，包装当前的操 作纯\")]),n._v(\" \"),a(\"li\",[n._v(\"把不纯的操作交给调用者来处理\")])]),n._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[n._v(\"  // IO函子\\nconst fp = require('lodash/fp');\\n\\nclass IO {\\n    static of(value) {\\n        return new IO(function() {\\n            return value\\n        })\\n    }\\n\\n    constructor(fn) {\\n        this._value = fn;\\n    }\\n\\n    map(fn) {\\n        return new IO(fp.flowRight(fn, this._value));\\n    }\\n}\\n\\nconst r = IO.of(process).map(p => p.execPath);\\nconsole.log(r);\\nconsole.log(r._value());\\n\\n\")])])]),a(\"h3\",{attrs:{id:\"task-异步执行\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#task-异步执行\"}},[n._v(\"#\")]),n._v(\" Task 异步执行\")]),n._v(\" \"),a(\"ul\",[a(\"li\",[n._v(\"异步任务的实现过于复杂，我们使用 folktale 中的 Task 来演示\")]),n._v(\" \"),a(\"li\",[a(\"a\",{attrs:{href:\"https://folktale.origamitower.com/\",target:\"_blank\",rel:\"noopener noreferrer\"}},[n._v(\"folktale\"),a(\"OutboundLink\")],1),n._v(\" 一个标准的函数式编程库\\n\"),a(\"ul\",[a(\"li\",[n._v(\"和 lodash、ramda 不同的是，他没有提供很多功能函数\")]),n._v(\" \"),a(\"li\",[n._v(\"只提供了一些函数式处理的操作，例如:compose、curry 等，一些函子 Task、Either、 MayBe 等\")])])])]),n._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[n._v(\"  // Task 处理异步任务\\nconst fs = require('fs')\\nconst { task } = require('folktale/concurrency/task')\\nconst { split, find } = require('lodash/fp')\\n\\nfunction readFile (filename) {\\n  return task(resolver => {\\n    fs.readFile(filename, 'utf-8', (err, data) => {\\n      if (err) resolver.reject(err)\\n\\n      resolver.resolve(data)\\n    })\\n  })\\n}\\n\\nreadFile('package.json')\\n  .map(split('\\\\n'))\\n  .map(find(x => x.includes('version')))\\n  .run()\\n  .listen({\\n    onRejected: err => {\\n      console.log(err)\\n    },\\n    onResolved: value => {\\n      console.log(value)\\n    }\\n  })\\n\")])])]),a(\"h3\",{attrs:{id:\"pointed-函子\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#pointed-函子\"}},[n._v(\"#\")]),n._v(\" Pointed 函子\")]),n._v(\" \"),a(\"ul\",[a(\"li\",[n._v(\"Pointed 函子是实现了 of 静态方法的函子\")]),n._v(\" \"),a(\"li\",[n._v(\"of 方法是为了避免使用 new 来创建对象，更深层的含义是 of 方法用来把值放到上下文 Context(把值放到容器中，使用 map 来处理值)\")])]),n._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[n._v(\"  class Container {\\n    static of (value) {\\n        return new Container(value)\\n    }\\n    ......\\n  }\\n  Contanier.of(2) .map(x => x + 5)\\n\")])])]),a(\"h3\",{attrs:{id:\"monad-单子\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#monad-单子\"}},[n._v(\"#\")]),n._v(\" Monad(单子)\")]),n._v(\" \"),a(\"p\",[n._v(\"在使用 IO 函子的时候，如果我们写出如下代码:\")]),n._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[n._v(\"  // IO 函子的问题\\nconst fs = require('fs')\\nconst fp = require('lodash/fp')\\n\\nclass IO {\\n  static of (value) {\\n    return new IO(value)\\n  }\\n\\n  constructor (fn) {\\n    this._value = fn\\n  }\\n\\n  map (fn) {\\n    return IO.of(fp.flowRight(fn, this._value))\\n  }\\n}\\n\\nlet readFile = function (filename) {\\n  return IO.of(function () {\\n    return fs.readFileSync(filename, 'utf-8')\\n  })\\n}\\n\\nlet print = function (x) {\\n  return IO.of(function () {\\n    console.log(x)\\n    return x\\n  })\\n}\\n\\nlet cat = fp.flowRight(print, readFile)\\n// IO(IO(x))\\nlet r = cat('package.json')._value()._value()\\nconsole.log(r)\\n\")])])]),a(\"p\",[n._v(\"以上使用 IO 函子导致调用\"),a(\"code\",[n._v(\"_value()\")]),n._v(\"过多，代码不清晰\")]),n._v(\" \"),a(\"ul\",[a(\"li\",[n._v(\"Monad 函子是可以变扁的 Pointed 函子，IO(IO(x))\")]),n._v(\" \"),a(\"li\",[n._v(\"一个函子如果具有 join 和 of 两个方法并遵守一些定律就是一个 Monad\")])]),n._v(\" \"),a(\"p\",[n._v(\"下面是一个处理打印\"),a(\"code\",[n._v(\"package.json\")]),n._v(\"的代码\")]),n._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[n._v(\"function showPackage(filename) {\\n  let package = fs.readFileSync(filename, 'utf-8');\\n  package = fp.toUpper(package);\\n  console.log(package)\\n}\\nshowPackage('package.json');\\n\")])])]),a(\"p\",[n._v(\"其中函数的第二行和第四行都是副作用，可以使用 IO Monad 把\"),a(\"strong\",[n._v(\"读取\")]),n._v(\"和\"),a(\"strong\",[n._v(\"打印\")]),n._v(\"两个副作用包裹起来\")]),n._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[n._v(\"// IO Monad\\nconst fs = require('fs')\\nconst fp = require('lodash/fp')\\n\\nclass IO {\\n  static of (value) {\\n    return new IO(value)\\n  }\\n\\n  constructor (fn) {\\n    this._value = fn\\n  }\\n\\n  map (fn) {\\n    return new IO(fp.flowRight(fn, this._value))\\n  }\\n\\n  join () {\\n    return this._value()\\n  }\\n\\n  flatMap (fn) {\\n    return this.map(fn).join()\\n  }\\n}\\n\\nlet readFile = function (filename) {\\n  return IO.of(function () {\\n    return fs.readFileSync(filename, 'utf-8')\\n  })\\n}\\n\\nlet print = function (x) {\\n  return IO.of(function () {\\n    console.log(x)\\n    return x\\n  })\\n}\\n\\nlet r = readFile('package.json')\\n          // .map(x => x.toUpperCase())\\n          .map(fp.toUpper)\\n          .flatMap(print)\\n          .join()\\n\\nconsole.log(r)\\n\")])])]),a(\"h2\",{attrs:{id:\"更多参考\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#更多参考\"}},[n._v(\"#\")]),n._v(\" 更多参考\")]),n._v(\" \"),a(\"ul\",[a(\"li\",[a(\"a\",{attrs:{href:\"https://llh911001.gitbooks.io/mostly-adequate-guide-chinese/content/ch1.html\",target:\"_blank\",rel:\"noopener noreferrer\"}},[n._v(\"函数式编程指北\"),a(\"OutboundLink\")],1)]),n._v(\" \"),a(\"li\",[a(\"a\",{attrs:{href:\"http://www.ruanyifeng.com/blog/2017/02/fp-tutorial.html\",target:\"_blank\",rel:\"noopener noreferrer\"}},[n._v(\"函数式编程入门\"),a(\"OutboundLink\")],1)]),n._v(\" \"),a(\"li\",[a(\"a\",{attrs:{href:\"http://www.ruanyifeng.com/blog/2017/03/pointfree.html\",target:\"_blank\",rel:\"noopener noreferrer\"}},[n._v(\"Pointfree 编程风格指南\"),a(\"OutboundLink\")],1)]),n._v(\" \"),a(\"li\",[a(\"a\",{attrs:{href:\"http://www.ruanyifeng.com/blog/2015/07/monad.html\",target:\"_blank\",rel:\"noopener noreferrer\"}},[n._v(\"图解 Monad\"),a(\"OutboundLink\")],1)]),n._v(\" \"),a(\"li\",[a(\"a\",{attrs:{href:\"https://adit.io/posts/2013-04-17-functors,_applicatives,_and_monads_in_pictures.html\",target:\"_blank\",rel:\"noopener noreferrer\"}},[n._v(\"Functors, Applicatives, And Monads In Pictures\"),a(\"OutboundLink\")],1)])])])}),[],!1,null,null,null);e.default=r.exports}}]);","extractedComments":[]}