(window.webpackJsonp=window.webpackJsonp||[]).push([[28],{395:function(e,n,s){"use strict";s.r(n);var o=s(27),t=Object(o.a)({},(function(){var e=this,n=e.$createElement,s=e._self._c||n;return s("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[s("h1",{attrs:{id:"关于模块化"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#关于模块化"}},[e._v("#")]),e._v(" 关于模块化")]),e._v(" "),s("h2",{attrs:{id:"模块化的早期演进过程"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#模块化的早期演进过程"}},[e._v("#")]),e._v(" 模块化的早期演进过程")]),e._v(" "),s("h3",{attrs:{id:"state1-文件划分方式"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#state1-文件划分方式"}},[e._v("#")]),e._v(" State1-文件划分方式")]),e._v(" "),s("p",[s("strong",[e._v("具体做法")])]),e._v(" "),s("p",[e._v("将每个功能及其相关状态数据各自单独放到不同的文件中，约定每个文件就是一个独立的模块，使用某个模块就是将这个模块引入到页面中，然后直接调用模块中的成员（变量 / 函数）")]),e._v(" "),s("p",[s("strong",[e._v("特点")]),e._v("：")]),e._v(" "),s("ul",[s("li",[e._v("所有模块都直接在全局工作，没有私有空间，所有成员都可以在模块外部被访问或者修改，")]),e._v(" "),s("li",[e._v("而且模块一段多了过后，容易产生命名冲突，")]),e._v(" "),s("li",[e._v("另外无法管理模块与模块之间的依赖关系")])]),e._v(" "),s("h3",{attrs:{id:"state2-命名空间方式"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#state2-命名空间方式"}},[e._v("#")]),e._v(" State2-命名空间方式")]),e._v(" "),s("p",[e._v("每个模块只暴露一个全局对象，所有模块成员都挂载到这个对象中")]),e._v(" "),s("p",[s("strong",[e._v("具体做法")])]),e._v(" "),s("p",[e._v("在第一阶段的基础上，通过将每个模块「包裹」为一个全局对象的形式实现，有点类似于为模块内的成员添加了「命名空间」的感觉。")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("// module a 相关状态数据和功能函数\n\nvar moduleA = {\n  name: 'module-a',\n\n  method1: function () {\n    console.log(this.name + '#method1')\n  },\n\n  method2: function () {\n    console.log(this.name + '#method2')\n  }\n}\n")])])]),s("p",[s("strong",[e._v("特点")])]),e._v(" "),s("ul",[s("li",[e._v("通过「命名空间」减小了命名冲突的可能，")]),e._v(" "),s("li",[e._v("但是同样没有私有空间，所有模块成员也可以在模块外部被访问或者修改，")]),e._v(" "),s("li",[e._v("而且也无法管理模块之间的依赖关系。")])]),e._v(" "),s("h3",{attrs:{id:"state3-iife"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#state3-iife"}},[e._v("#")]),e._v(" State3-IIFE")]),e._v(" "),s("p",[e._v("使用立即执行函数表达式（IIFE：Immediately-Invoked Function Expression）为模块提供私有空间。")]),e._v(" "),s("p",[s("strong",[e._v("具体做法")])]),e._v(" "),s("p",[e._v("将每个模块成员放在一个函数提供的私有作用域中，对于需要暴露给外部的成员，通过挂载到全局对象的方式实现")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("// module a 相关状态数据和功能函数\n\n;(function () {\n  var name = 'module-a'\n\n  function method1 () {\n    console.log(name + '#method1')\n  }\n\n  function method2 () {\n    console.log(name + '#method2')\n  }\n\n  window.moduleA = {\n    method1: method1,\n    method2: method2\n  }\n})()\n\n")])])]),s("p",[s("strong",[e._v("特点")])]),e._v(" "),s("ul",[s("li",[e._v("有了私有成员的概念，私有成员只能在模块成员内通过闭包的形式访问。")])]),e._v(" "),s("p",[e._v("上述做法就是我们模块化的基础，为了减少项目开发时的引用模块时造成的麻烦，提高开发效率，我们需要代码帮我们按照一定标准自动加载模块，此后模块化的标准逐渐形成，通行的 JavaScript 模块规范主要有三种："),s("strong",[e._v("CommonJS")]),e._v("、"),s("strong",[e._v("AMD")]),e._v("、"),s("strong",[e._v("ES Modules")])]),e._v(" "),s("h2",{attrs:{id:"commonjs"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#commonjs"}},[e._v("#")]),e._v(" CommonJS")]),e._v(" "),s("p",[e._v("CommonJS 是 nodejs 提出的一套规范，在 nodejs 中必须遵循这套规范。")]),e._v(" "),s("p",[s("strong",[e._v("CommonJS 约定")])]),e._v(" "),s("ul",[s("li",[e._v("一个文件就是一个模块")]),e._v(" "),s("li",[e._v("每个模块都有单独的作用域")]),e._v(" "),s("li",[e._v("通过 module.exports 导出成员")]),e._v(" "),s("li",[e._v("通过 require 函数载入模块")])]),e._v(" "),s("p",[e._v("来看下面代码：")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("//模块定义 myModel.js\nvar name = 'licop';\n\nfunction consoleName(){\n    console.log(name);\n}\n\nmodule.exports = {\n    consoleName: consoleName\n}\n\n//加载模块\nvar nameModule = require('./myModel.js');\nnameModule.consoleName();\n\n")])])]),s("p",[e._v("CommonJS 是以"),s("strong",[e._v("同步方式")]),e._v("加载模块，node 的执行机制是在启动时加载模块，在执行时是不需要加载的。但是在浏览器端使用每次页面加载都会导致大量的同步请求出现， 会导致效率低下。")]),e._v(" "),s("h2",{attrs:{id:"amd"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#amd"}},[e._v("#")]),e._v(" AMD")]),e._v(" "),s("p",[e._v("犹豫 Commonjs 规范在浏览器端的，所以在早期的前端的模块化规范并没有使用 CommonJS 规范，而是结合浏览器的特点设计了新的规范 AMD(Asynchronous Module Definition)。")]),e._v(" "),s("p",[s("code",[e._v("requirejs")]),e._v("实现了 AMD 规范，而且是一个强大的模块加载器。")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("// 使用define定义一个模块\n// 第一个参数为模块的名字\n// 第二个参数是一个数组用来声明模块的依赖项\n// 第三个参数是一个函数，参数与前端依赖项一一对应，为当前某块提供私有的空间\ndefine('module1', ['jquery', './module2'], function ($, module2) {\n  return {\n    start: function () {\n      $('body').animate({ margin: '200px' })\n      module2()\n    }\n  }\n})\n\n// 使用require载入一个模块\nrequire(['./modules/module1'], function (module1) {\n  module1.start()\n})\n\n")])])]),s("p",[e._v("当"),s("code",[e._v("requirejs")]),e._v("需要加载一个模块的话，会自动创建一个 script 标签，发送文件请求。")]),e._v(" "),s("p",[e._v("目前绝大多数第三方库都支持 AMD 规范。")]),e._v(" "),s("p",[e._v("但是 AMD 使用也有一些缺点：")]),e._v(" "),s("ul",[s("li",[e._v("AMD 使用起来相对复杂")]),e._v(" "),s("li",[e._v("模块 js 文件请求频繁")])]),e._v(" "),s("h2",{attrs:{id:"es-modules"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#es-modules"}},[e._v("#")]),e._v(" ES Modules")]),e._v(" "),s("p",[e._v("模块化最佳实践")]),e._v(" "),s("ul",[s("li",[e._v("浏览器端使用 ES Modules 规范")]),e._v(" "),s("li",[e._v("nodejs 使用 CommonJS 规范")])]),e._v(" "),s("p",[e._v("目前市面上大多数浏览器已经支持了 ES Module\n"),s("img",{attrs:{src:"/engineering/es6_module.png",alt:""}})]),e._v(" "),s("h3",{attrs:{id:"es-modules-基本特性"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#es-modules-基本特性"}},[e._v("#")]),e._v(" ES Modules 基本特性")]),e._v(" "),s("ul",[s("li",[e._v("自动采用严格模式，忽略'use strict'")]),e._v(" "),s("li",[e._v("每个 ESM 模块都是单独的作用域")]),e._v(" "),s("li",[e._v("ESM 是通过 CORS 去请求外部作用域的")]),e._v(" "),s("li",[e._v("ESM 的 script 标签会延迟执行脚本")])]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v(' \x3c!-- 通过给 script 添加 type = module 的属性，就可以以 ES Module 的标准执行其中的 JS 代码了 --\x3e\n  <script type="module">\n    console.log(\'this is es module\')\n  <\/script>\n\x3c!-- 只能在不支持ES Module的浏览器下执行 --\x3e\n  <script type="module">\n  <script nomodule>\n    console.log(\'this is es module\')\n  <\/script>\n\n\n  \x3c!-- 1. ESM 自动采用严格模式，忽略 \'use strict\' --\x3e\n  <script type="module">\n    console.log(this) // undefined\n  <\/script>\n\n  \x3c!-- 2. 每个 ES Module 都是运行在单独的私有作用域中 --\x3e\n  <script type="module">\n    var foo = 100\n    console.log(foo)  // 100\n  <\/script>\n  <script type="module">\n    console.log(foo)\n  <\/script>\n\n  \x3c!-- 3. ESM 是通过 CORS 的方式请求外部 JS 模块的 --\x3e\n  <script type="module" src="https://unpkg.com/jquery@3.4.1/dist/jquery.min.js"><\/script>\n\n  \x3c!-- 4. ESM 的 script 标签会延迟执行脚本 和defer属性功能相同，等待网页渲染完成之后再去执行脚本 --\x3e\n  <script type="module" src="demo.js"><\/script>\n  <script defer src="demo.js"><\/script>\n\n')])])]),s("h3",{attrs:{id:"es-modules-的导入导出"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#es-modules-的导入导出"}},[e._v("#")]),e._v(" ES Modules 的导入导出")]),e._v(" "),s("p",[e._v("使用 export 导出模块")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("var name = 'foo module'\n\nfunction hello () {\n  console.log('hello')\n}\n\nclass Person {}\n\n// 导出成员\n// 这里的`{ name, hello, Person }`不是对象字面量，只是语法上的规则而已\nexport { name, hello, Person }\n\n// 使用别名\nexport {\n  hello as fooHello\n}\n// 导出默认\nexport default name\n\n")])])]),s("p",[e._v("使用 import 导入模块")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("// 导入模块时如果没有使用打包工具，import应该使用完成路径导入\nimport { name } from './module.js'\nimport { lowercase } from './utils/index.js'\n\n\n// 加载模块并不提取它\nimport {} from './module.js'\nimport './module.js'\n\n// 提出模块导出的所有成员\nimport * from './module.js'\n// 将导出成员放在一个对象中\nimport * as mod from './module.js'\n\n\n// import路径不能使用变量\nvar modulePath = './module.js'\nimport {name} from modulePath\n// import只能出现在最外部的作用域，下面错误使用方法\nif(true) {\n    import {name} from './module.js'\n}\n// 动态导入模块\nimport('./module.js').then(function(moudle) {\n   console.log(module)\n})\n\n// 提取默认成员\nimport { name, age, default as abc } from './module.js'\nimport abc, { name, age } from './module.js'\n")])])]),s("p",[e._v("导出导入成员")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("export { default as Button } from './button.js'\nexport { Avatar } from './avatar.js'\n")])])]),s("p",[s("strong",[e._v("注意事项")])]),e._v(" "),s("ul",[s("li",[e._v("这里的无论是导入导出的花括号不使用 default 的情况是都"),s("code",[e._v("{ name, hello, Person }")]),e._v("不是对象字面量，只是语法上的规则而已")]),e._v(" "),s("li",[e._v("导入模块成员变量是只读的常量,导入后不能修改，但是需要注意如果导入的是一个对象，对象的属性读写不受影响")]),e._v(" "),s("li",[e._v("导入成员并不是复制一个副本，而是直接导入模块成员的引用地址，也就是说 import 得到的变量与 export 导入的变量在内存中是同一块空间。")])]),e._v(" "),s("h2",{attrs:{id:"es-modules-in-node-js"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#es-modules-in-node-js"}},[e._v("#")]),e._v(" ES Modules in Node.js")]),e._v(" "),s("p",[e._v("Node.js 在 8.5 版本过后内部已经以实验的特性支持了 ES Modules。")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("// 第一，将文件的扩展名由 .js 改为 .mjs；\n// 第二，启动时需要额外添加 `--experimental-modules` 参数；\n\nimport { foo, bar } from './module.mjs'\n\nconsole.log(foo, bar)\n\n// 此时我们也可以通过 esm 加载内置模块了\nimport fs from 'fs'\nfs.writeFileSync('./foo.txt', 'es module working')\n\n// 也可以直接提取模块内的成员，内置模块兼容了 ESM 的提取成员方式\nimport { writeFileSync } from 'fs'\nwriteFileSync('./bar.txt', 'es module working')\n\n// 对于第三方的 NPM 模块也可以通过 esm 加载\nimport _ from 'lodash'\n_.camelCase('ES Module')\n\n// 不支持，因为第三方模块都是导出默认成员\n// import { camelCase } from 'lodash'\n// console.log(camelCase('ES Module'))\n")])])]),s("p",[e._v("Node v12 之后的版本，可以通过 package.json 中添加 type 字段为 module，将默认模块系统修改为 ES Module,此时就不需要修改文件扩展名为 .mjs 了,不过如果此时要使用 commonjs 规范文件扩展名为需改为.cjs。")]),e._v(" "),s("p",[e._v("在 node 中同时使用 ES Modules 和 Commonjs 要注意:")]),e._v(" "),s("ul",[s("li",[e._v("ES Modules 中可以导入 Commonjs 模块")]),e._v(" "),s("li",[e._v("CommonJS 中不能导入 ES Modules 模块")]),e._v(" "),s("li",[e._v("Commonjs 始终只会导出一个默认成员")]),e._v(" "),s("li",[e._v("ES Modules 不能使用 CommonJS 的模块全局成员 require(加载模块函数)、exports(导出对象别名)、module(模块对象)、__filename(当前文件的绝对路径)、__dirname(当前文件的所在的目录）")])]),e._v(" "),s("h2",{attrs:{id:"es-modules-babel-兼容方案"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#es-modules-babel-兼容方案"}},[e._v("#")]),e._v(" ES Modules Babel 兼容方案")]),e._v(" "),s("p",[s("strong",[e._v("安装 Babel 和预设插件")])]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("npm install @babel/node @babel/core @babel/preset-env\n")])])]),s("p",[s("strong",[e._v("配置.babelrc")])]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("// .babelrc\n{\n    'presets': [\"@babel/preset-env\"]\n}\n")])])]),s("p",[e._v("babel 是基于插件机制实现的，核心模块并不会转换代码，而是通过插件来实现的，需要一个插件来转化代码中的一个特性，而"),s("code",[e._v("@babel/preset-env")]),e._v(" 是插件的集合，包含了 javascript 标准里所有的新特性。")]),e._v(" "),s("p",[s("img",{attrs:{src:"/engineering/babel%E6%8F%92%E4%BB%B6%E6%9C%BA%E5%88%B6.png",alt:""}})]),e._v(" "),s("p",[e._v("所以可也可以单独使用插件"),s("code",[e._v("@babel/transform-modules-commonjs")]),e._v("来代替"),s("code",[e._v("@babel/preset-env")])]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("// .babelrc\n{\n'plugins': [\"@babel/transform-modules-commonjs\"]\n}\n")])])])])}),[],!1,null,null,null);n.default=t.exports}}]);