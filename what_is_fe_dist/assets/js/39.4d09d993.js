(window.webpackJsonp=window.webpackJsonp||[]).push([[39],{404:function(s,t,a){"use strict";a.r(t);var n=a(27),e=Object(n.a)({},(function(){var s=this,t=s.$createElement,a=s._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[a("h1",{attrs:{id:"react-项目的文件目录结构"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#react-项目的文件目录结构"}},[s._v("#")]),s._v(" React 项目的文件目录结构")]),s._v(" "),a("p",[s._v("在前端工程化和团队协作的基础上，大型 React 项目代码量上 10 万很常见。项目从最初的几行代码到如今的数十万代码，你可能会遇到如下问题：")]),s._v(" "),a("ul",[a("li",[s._v("新功能的组件、Hooks、样式要不要分文件写，源文件都放到哪里？")]),s._v(" "),a("li",[s._v("Redux 的 action、reducer、store 都写到哪里？")]),s._v(" "),a("li",[s._v("公共的代码放到哪里？")]),s._v(" "),a("li",[s._v("代码文件多到找不到怎么办？")])]),s._v(" "),a("p",[s._v("大中型 React 项目在代码增多，项目整体的扩展就会遇到挑战，这时目录结构组件就变的重要了。")]),s._v(" "),a("h2",{attrs:{id:"几种典型的-react-项目文件目录"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#几种典型的-react-项目文件目录"}},[s._v("#")]),s._v(" 几种典型的 React 项目文件目录")]),s._v(" "),a("p",[s._v("项目源码的文件目录结构并不等同于应用的整体逻辑，但却可以"),a("strong",[s._v("作为把握应用整体逻辑的一张“地图”")]),s._v("。一个良好的文件目录结构是"),a("strong",[s._v("自解释")]),s._v("的，可以帮助新接触项目的开发者快速熟悉代码逻辑。")]),s._v(" "),a("p",[s._v("React 应用项目有以下五种典型的文件目录结构：")]),s._v(" "),a("ul",[a("li",[s._v("单文件结构；")]),s._v(" "),a("li",[s._v("单目录结构；")]),s._v(" "),a("li",[s._v("按文件职能划分目录结构；")]),s._v(" "),a("li",[s._v("按组件划分目录结构；")]),s._v(" "),a("li",[s._v("按业务功能划分目录结构。")])]),s._v(" "),a("h3",{attrs:{id:"单文件结构"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#单文件结构"}},[s._v("#")]),s._v(" 单文件结构")]),s._v(" "),a("p",[s._v("单文件结构就是指，在单个 React 组件文件中开发所有业务逻辑。比如说不算样式的话，我们把所有代码都写在了 "),a("code",[s._v("src/app.js")]),s._v(" 中。需要注意的是，这种结构只适合代码演示或微型的 React 项目。")]),s._v(" "),a("h3",{attrs:{id:"单目录结构"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#单目录结构"}},[s._v("#")]),s._v(" 单目录结构")]),s._v(" "),a("p",[s._v("比起单文件结构，这种结构拆分了组件文件，拆分的文件都放在同一个目录下。")]),s._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[s._v("src\n├── App"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),s._v("css\n├── App"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),s._v("js\n├── KanbanBoard"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),s._v("js\n├── KanbanCard"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),s._v("js\n├── KanbanColumn"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),s._v("js\n├── KanbanNewCard"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),s._v("js\n├── index"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),s._v("css\n└── index"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),s._v("js\n")])])]),a("p",[s._v("单目录结构比起单文件结构，能支撑更多组件以及相关逻辑，适合微型 React 项目。")]),s._v(" "),a("h3",{attrs:{id:"按文件职能划分目录结构"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#按文件职能划分目录结构"}},[s._v("#")]),s._v(" 按文件职能划分目录结构")]),s._v(" "),a("p",[s._v("顾名思义，在这种结构下，组件文件放一个目录，自定义 Hooks 文件放一个目录，context 文件放一个目录，如果使用了 Redux 的话，actions、reducers、store 各占一个目录（或者 Redux Toolkit 的 slices 和 store 目录）。")]),s._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[s._v("src\n├── components\n│   ├── App"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),s._v("css\n│   ├── App"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),s._v("tsx\n│   ├── KanbanBoard"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),s._v("tsx\n│   ├── KanbanCard"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),s._v("tsx\n│   ├── KanbanColumn"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),s._v("tsx\n│   └── KanbanNewCard"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),s._v("tsx\n├── context\n│   └── AdminContext"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),s._v("ts\n├── hooks\n│   └── useFetchCards"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),s._v("ts\n├── actions\n├── reducers\n├── store\n├── types\n├   └── KanbanCard"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),s._v("types"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),s._v("ts\n├── index"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),s._v("css\n└── index"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),s._v("tsx\n")])])]),a("p",[s._v("按文件职能划分目录结构的优点在于，可以快速定位任何一种类型的源码，在源码之间导入导出也比较方便：")]),s._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// src/components/App.tsx")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("import")]),s._v(" AdminContext "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("from")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[s._v('"../context/AdminContext"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n")])])]),a("p",[s._v("当其中某个或者某几个目录中的文件数不断增多时，这种结构的缺点就暴露出来了：不容易定位到直接相关的源文件。比如 hooks/useFetchCards.ts 目前只有 components/App.tsx 在用，这从目录结构上是看不出来的，必须进到源码里去看，当 components 目录下的文件足够多时，要花些功夫才能确认这两个文件的关联关系。")]),s._v(" "),a("h3",{attrs:{id:"按组件划分目录结构"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#按组件划分目录结构"}},[s._v("#")]),s._v(" 按组件划分目录结构")]),s._v(" "),a("p",[s._v("这种目录结构为每个组件都划分了一个独立、平级的目录，只要跟这个组件强相关，都往这个目录里招呼。\n这种设计出于两个考虑：")]),s._v(" "),a("ul",[a("li",[s._v("React 的基本开发单元是组件；")]),s._v(" "),a("li",[s._v("同一组件的相关代码要尽量"),a("strong",[s._v("共置")])])]),s._v(" "),a("p",[s._v("目录树结构的例子如下：")]),s._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[s._v("src\n├── components\n│   ├── App\n│   │   ├── AdminContext"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),s._v("js\n│   │   ├── App"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),s._v("css\n│   │   ├── App"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),s._v("jsx\n│   │   ├── App"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),s._v("test"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),s._v("jsx\n│   │   ├── index"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),s._v("js\n│   │   └── useFetchCards"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),s._v("js\n│   ├── KanbanBoard\n│   │   ├── KanbanBoard"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),s._v("css\n│   │   ├── KanbanBoard"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),s._v("jsx\n│   │   └── index"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),s._v("js\n│   ├── KanbanCard\n│   │   ├── KanbanCard"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),s._v("css\n│   │   ├── KanbanCard"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),s._v("jsx\n│   │   ├── KanbanNewCard"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),s._v("jsx\n│   │   └── index"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),s._v("js\n│   └── KanbanColumn\n│       ├── KanbanColumn"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),s._v("css\n│       ├── KanbanColumn"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),s._v("jsx\n│       └── index"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),s._v("js\n├── index"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),s._v("css\n└── index"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),s._v("jsx\n")])])]),a("p",[s._v("在每个目录中都有一个 index.js，负责把当前目录的组件重新导出（Re-export）到目录外面去，这样其他组件在导入这个组件时，不需要关心目录里都有哪些实现，只关注作为入口的 index.js 就行。入口文件示意代码如下：")]),s._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// src/components/KanbanCard/index.js")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("export")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("default")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("as")]),s._v(" KanbanCard "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("from")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[s._v('"./KanbanCard.jsx"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("export")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("default")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("as")]),s._v(" KanbanNewCard "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("from")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[s._v('"./KanbanNewCard.jsx"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n")])])]),a("p",[s._v("这种目录结构的优势在于，能为特定组件提供一定的封装性，在它专属的目录中能找到它强相关的所有代码。但它也有不足，面对一些跨组件复用的逻辑，可能会出现放到哪个组件目录都不太合适的窘境。")]),s._v(" "),a("h3",{attrs:{id:"按业务功能划分目录结构"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#按业务功能划分目录结构"}},[s._v("#")]),s._v(" 按业务功能划分目录结构")]),s._v(" "),a("p",[s._v("按业务功能划分目录结构，它与我们刚刚讲过的结构都不同，意味着目录划分的主要依据不再是具体框架中的某个具体技术概念（包括 React 的组件、Hooks、context，也包括 Redux 的 action、reducer、store）。这使得按业务功能划分目录结构成为一个框架无关的方案，也就是说，其他框架的应用也可以利用这种目录结构。")]),s._v(" "),a("p",[s._v("目录树结构的例子如下：")]),s._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[s._v("src\n├── features\n│   ├── admin\n│   │   ├── AdminContext"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),s._v("js\n│   │   ├── AdminDashboard"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),s._v("jsx\n│   │   ├── AdminSettings"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),s._v("jsx\n│   │   └── index"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),s._v("js\n│   ├── kanban\n│   │   ├── KanbanBoard"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),s._v("jsx\n│   │   ├── KanbanCard"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),s._v("jsx\n│   │   ├── KanbanColumn"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),s._v("jsx\n│   │   ├── KanbanNewCard"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),s._v("jsx\n│   │   ├── index"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),s._v("js\n│   │   └── useFetchCards"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),s._v("js\n│   ├── login\n│   │   ├── Login"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),s._v("css\n│   │   ├── Login"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),s._v("jsx\n│   │   ├── LoginForm"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),s._v("jsx\n│   │   └── index"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),s._v("js\n│   └── user\n│       ├── Password"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),s._v("jsx\n│       ├── UserProfile"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),s._v("jsx\n│       ├── UserSettings"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),s._v("jsx\n│       └── index"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),s._v("js\n├── index"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),s._v("css\n└── index"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),s._v("jsx\n")])])]),a("p",[s._v("按业务功能划分目录结构可以说，它是这五种结构中最适合大中型 React 项目的。它既强调了相关源文件的共置，也在增加业务功能时具有良好的可扩展性。但它也具有与按组件划分目录结构类似的缺点，面对一些跨业务功能复用的逻辑，放在哪个业务目录下都不太合适。")]),s._v(" "),a("h3",{attrs:{id:"如何选取合适的文件目录结构"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#如何选取合适的文件目录结构"}},[s._v("#")]),s._v(" 如何选取合适的文件目录结构？")]),s._v(" "),a("p",[a("img",{attrs:{src:"/framework/react_base_10.png",alt:""}})]),s._v(" "),a("h3",{attrs:{id:"前端应用逻辑架构的功用"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#前端应用逻辑架构的功用"}},[s._v("#")]),s._v(" 前端应用逻辑架构的功用")]),s._v(" "),a("p",[s._v("无论是否精确、美观，这样的架构图有助于我们把握项目的整体走向，对于大中型 React 项目而言是一个值得的先期投入。")]),s._v(" "),a("p",[a("img",{attrs:{src:"/framework/react_base_11.png",alt:""}})]),s._v(" "),a("h3",{attrs:{id:"大中型-react-项目推荐的文件目录结构"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#大中型-react-项目推荐的文件目录结构"}},[s._v("#")]),s._v(" 大中型 React 项目推荐的文件目录结构")]),s._v(" "),a("p",[s._v("当 React 项目规模属于中型或大型时，文件目录结构需要满足以下几个目标：")]),s._v(" "),a("ul",[a("li",[s._v("便于横向扩展（即增加新功能点或视图）；")]),s._v(" "),a("li",[s._v("易于定位相关代码；鼓励代码复用；")]),s._v(" "),a("li",[s._v("有利于团队协作。")])]),s._v(" "),a("p",[s._v("为了满足上面的目标，推荐以按业务功能划分为主，结合按组件、按文件职能的方式，划分目录结构。")]),s._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[s._v("src\n├── components\n│   ├── Button\n│   ├── Dialog\n│   ├── ErrorBoundary\n│   ├── Form\n│   │   ├── Form"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),s._v("css\n│   │   ├── FormField"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),s._v("jsx\n│   │   ├── Form"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),s._v("jsx\n│   │   └── index"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),s._v("js\n│   ├── "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("...")]),s._v("\n│   └── Tooltip\n├── context\n│   ├── "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("...")]),s._v("\n│   └── UserContext"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),s._v("js\n├── features\n│   ├── admin\n│   ├── dashboard\n│   │   ├── activies\n│   │   │   └── ActivityList"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),s._v("jsx\n│   │   ├── charts\n│   │   │   └── "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("...")]),s._v("\n│   │   ├── news\n│   │   │   ├── news"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),s._v("png\n│   │   │   ├── NewsDetail"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),s._v("jsx\n│   │   │   └── NewsList"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),s._v("jsx\n│   │   ├── Dashboard"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),s._v("css\n│   │   ├── Dashboard"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),s._v("jsx\n│   │   └── index"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),s._v("js\n│   ├── kanban\n│   │   ├── KanbanBoard"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),s._v("jsx\n│   │   ├── index"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),s._v("js\n│   │   └── useFetchCards"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),s._v("js\n│   ├── home\n│   ├── login\n│   ├── "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("...")]),s._v("\n│   └── user\n├── hooks\n│   ├── "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("...")]),s._v("\n│   └── useLocation"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),s._v("js\n├── servies\n│   ├── kanbanService"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),s._v("js\n│   ├── "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("...")]),s._v("\n│   └── userService"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),s._v("js\n├── index"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),s._v("css\n└── index"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),s._v("jsx\n")])])]),a("p",[s._v("对应上面的例子，首先建立 features 目录， features 下面的一级目录都对应一个相对完整的业务功能，目录中有实现这一功能的各类代码。")]),s._v(" "),a("p",[s._v("对于部分体量比较大的功能，可以根据需要在一级目录下加入二级目录，每个二级目录都对应一个相对独立的子功能（业务），目录内部是实现子功能的各类代码。必要时还可以加入三级、四级目录，但总体目录层级不应过深。所以我们说，在 features 目录，可以从横向、纵向两个方向扩展功能点。")]),s._v(" "),a("p",[s._v("在 features 目录之外，为公用的代码建立一系列职能型的目录，包括可重用组件的 components 目录、可重用 Hooks 的 hooks 目录； context 目录的主要目的不是重用，而是跨业务功能使用 context； services 目录下，集中定义了整个应用会用到的远程服务，避免四散到各个业务模块中，甚至硬编码（Hardcode）。这些公用代码的目录层级不宜太深，以一到二级为主。")]),s._v(" "),a("p",[s._v("从代码的导入导出关系来看，在 features 目录下，原则上同级目录间的文件不应互相导入，二级、三级目录只应被直接上一级目录导入，不能反过来被下一级目录导入。features 目录的代码可以导入公用目录的代码，反过来公用目录的代码不能导入 features 目录的代码。在任何时候都应该避免循环导入（Circular Import）。")]),s._v(" "),a("p",[s._v("目前为止的目录结构，都是以单个 React 项目为前提的。")]),s._v(" "),a("p",[s._v("根据实际项目需要，也有很多 React 项目使用了多项目或者 monorepo 的方式来开发和扩展，虽然编译构建、CI/CD 更加复杂了，但更有利于多个团队的协作，提高整体开发效率。在这样的实践中，可以把追加功能点到同一个 React 项目（或 monorepo 的包）看作纵向扩展，把特定模块、可复用组件和逻辑抽取为独立 React 项目（或 monorepo 的包）看作横向扩展。")])])}),[],!1,null,null,null);t.default=e.exports}}]);