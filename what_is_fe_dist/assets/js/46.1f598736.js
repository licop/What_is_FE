(window.webpackJsonp=window.webpackJsonp||[]).push([[46],{413:function(t,a,s){"use strict";s.r(a);var e=s(27),r=Object(e.a)({},(function(){var t=this,a=t.$createElement,s=t._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"编写-react-应用程序步骤"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#编写-react-应用程序步骤"}},[t._v("#")]),t._v(" 编写 React 应用程序步骤")]),t._v(" "),s("p",[t._v("此笔记参考官方文档"),s("a",{attrs:{href:"https://zh-hans.reactjs.org/docs/thinking-in-react.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("reactjs 哲学"),s("OutboundLink")],1),t._v("并结合自己的项目经历总结")]),t._v(" "),s("p",[t._v("对于 React 应用开发的思路应该是，"),s("strong",[t._v("从整体到局部，从简单到复杂，从视图到交互，从数据到逻辑")]),t._v("。")]),t._v(" "),s("h3",{attrs:{id:"将设计好的-ui-划分为组件层级并设计好数据模型"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#将设计好的-ui-划分为组件层级并设计好数据模型"}},[t._v("#")]),t._v(" 将设计好的 UI 划分为组件层级并设计好数据模型")]),t._v(" "),s("ul",[s("li",[t._v("根据单一功能原则判定组件范围，一个组件原则上只负责一个功能")]),t._v(" "),s("li",[t._v("将 UI 分离为组件，其中每个组件需与数据模型的某部分匹配")])]),t._v(" "),s("h3",{attrs:{id:"用数据模型渲染一个不不含交互功能的-ui-的静态版本"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#用数据模型渲染一个不不含交互功能的-ui-的静态版本"}},[t._v("#")]),t._v(" 用数据模型渲染一个不不含交互功能的 ui 的静态版本")]),t._v(" "),s("ul",[s("li",[t._v("不需要考虑交互细节")]),t._v(" "),s("li",[t._v("这时只需通过 props 传递像组件传递数据，不需要使用 state")]),t._v(" "),s("li",[t._v("当你的应用比较简单时，使用自上而下的方式更方便；对于较为大型的项目来说，自下而上地构建，并同时为低层组件编写测试是更加简单的方式")])]),t._v(" "),s("h3",{attrs:{id:"确定-ui-state-的最小-且完整-表示"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#确定-ui-state-的最小-且完整-表示"}},[t._v("#")]),t._v(" 确定 UI state 的最小（且完整）表示")]),t._v(" "),s("ul",[s("li",[t._v("只保留应用所需的可变 state 的"),s("strong",[t._v("最小集合")]),t._v("，其他数据均由它们计算产生，不能滥用和重复。")]),t._v(" "),s("li",[t._v("确实 state 三条原则：\n"),s("ol",[s("li",[t._v("该数据是否是由父组件通过 props 传递而来的？如果是，那它应该不是 state。")]),t._v(" "),s("li",[t._v("该数据是否随时间的推移而保持不变？如果是，那它应该也不是 state。")]),t._v(" "),s("li",[t._v("你能否根据其他 state 或 props 计算出该数据的值？如果是，那它也不是 state。")])])])]),t._v(" "),s("h3",{attrs:{id:"确定-state-的放置位置"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#确定-state-的放置位置"}},[t._v("#")]),t._v(" 确定 state 的放置位置")]),t._v(" "),s("ul",[s("li",[t._v("找到根据这个 state 渲染的所有组件")]),t._v(" "),s("li",[t._v("找到这些组件的共同所有则组件（在组件层级上高于所有需要该 state 的组件）")]),t._v(" "),s("li",[t._v("该共同所有者组件或者比它层级更高的组件拥有该 state")]),t._v(" "),s("li",[t._v("如果你找不到一个合适的位置来存放该 state，就可以直接创建一个新组件来存放该 state，并将这一新组件置于高于共同所有者组件层级的位置。")])]),t._v(" "),s("h3",{attrs:{id:"添加反向数据流"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#添加反向数据流"}},[t._v("#")]),t._v(" 添加反向数据流")]),t._v(" "),s("ul",[s("li",[t._v("通过传递函数方法处于较低层级的组件更新较高层级的组件中的 state")])])])}),[],!1,null,null,null);a.default=r.exports}}]);