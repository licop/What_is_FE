(window.webpackJsonp=window.webpackJsonp||[]).push([[32],{399:function(e,n,s){"use strict";s.r(n);var t=s(27),a=Object(t.a)({},(function(){var e=this,n=e.$createElement,s=e._self._c||n;return s("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[s("h1",{attrs:{id:"promise-源码实现"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#promise-源码实现"}},[e._v("#")]),e._v(" promise 源码实现")]),e._v(" "),s("p",[e._v("用了"),s("code",[e._v("Promise")]),e._v("这么久，应该对"),s("code",[e._v("Promise")]),e._v("使用方法和相关属性很熟悉了，本文将一步一步编写"),s("code",[e._v("Promise")]),e._v("的源码，实现其基本功能。")]),e._v(" "),s("h2",{attrs:{id:"promise-类核心逻辑实现"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#promise-类核心逻辑实现"}},[e._v("#")]),e._v(" Promise 类核心逻辑实现")]),e._v(" "),s("p",[e._v("在写代码先看一下 Promise 的一些基础特性：")]),e._v(" "),s("ul",[s("li",[s("code",[e._v("Promise")]),e._v(" 就是一个类 在执行这个类的时候 需要传递一个执行器进去 执行器会立即执行")]),e._v(" "),s("li",[s("code",[e._v("Promise")]),e._v("中有三种状态 分别为 成功 "),s("code",[e._v("fulfilled")]),e._v(" 失败 "),s("code",[e._v("rejected")]),e._v(" 等待 "),s("code",[e._v("pending")]),e._v("\n其中状态只能从 "),s("code",[e._v("pending")]),e._v(" -> "),s("code",[e._v("fulfilled")]),e._v(" 或 "),s("code",[e._v("pending")]),e._v(" -> "),s("code",[e._v("rejected")]),e._v(" 一旦状态确定就不可更改")]),e._v(" "),s("li",[s("code",[e._v("resolve")]),e._v(" 和 "),s("code",[e._v("reject")]),e._v(" 函数是用来更改状态的")]),e._v(" "),s("li",[s("code",[e._v("then")]),e._v(" 方法内部做的事情就判断状态 如果状态是成功 调用成功的回调函数 如果状态是失败 调用失败回调函数 then 方法是被定义在原型对象中的")]),e._v(" "),s("li",[s("code",[e._v("then")]),e._v(" 成功回调有一个参数 表示成功之后的值 then 失败回调有一个参数 表示失败后的原因")]),e._v(" "),s("li",[e._v("同一个 "),s("code",[e._v("promise")]),e._v(" 对象下面的 "),s("code",[e._v("then")]),e._v(" 方法是可以被调用多次的")]),e._v(" "),s("li",[s("code",[e._v("then")]),e._v(" 方法是可以被链式调用的, 后面 "),s("code",[e._v("then")]),e._v(" 方法的回调函数拿到值的是上一个 "),s("code",[e._v("then")]),e._v(" 方法的回调函数的返回值")])]),e._v(" "),s("p",[e._v("由以上特性实现 "),s("code",[e._v("Promise")]),e._v(" 类的核心逻辑, 除了"),s("code",[e._v("then")]),e._v(" 方法链式调用功能")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("const PENDING = 'pending'; // 等待\nconst FULFILLED = 'fullilled' // 成功\nconst REJECTED = 'rejected' // 失败\n\nclass MyPromise {\n  constructor(executor) {\n    executor(this.resolve, this.reject)\n  }\n  // promise 状态\n  status = PENDING;\n  // 成功之后的值\n  value = undefined;\n  // 失败之后的值\n  reason = undefined;\n\n\n  resolve = (value) => {\n    if(this.status !== PENDING) return;\n    // 将状态更改为成功\n    this.status = FULFILLED;\n    // 保存成功之后的值\n    this.value = value\n  }\n\n  reject = (reason) => {\n    if(this.status !== PENDING) return;\n    // 将状态更改为失败\n    this.status = REJECTED;\n    this.reason = reason;\n  }\n\n  then = (successCallback, failCallback) => {\n    // 判断状态\n    if(this.status === FULFILLED) {\n      successCallback(this.value);\n    } else if(this.status === REJECTED) {\n      failCallback(this.reason);\n    }\n  }\n}\n\n")])])]),s("h2",{attrs:{id:"加入异步逻辑"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#加入异步逻辑"}},[e._v("#")]),e._v(" 加入异步逻辑")]),e._v(" "),s("p",[e._v("可以发现以上代码当"),s("code",[e._v("executor")]),e._v("内包含异步代码是有问题的，"),s("code",[e._v("then")]),e._v("方法开始执行后，"),s("code",[e._v("resolve")]),e._v("方法调用还没改变状态，所以异步函数没有调用。")]),e._v(" "),s("p",[s("code",[e._v("then")]),e._v(" 方法加入异步逻辑,等异步任务执行完在执行回调函数，将回调函数在 "),s("code",[e._v("pending")]),e._v(" 状态下存储起来，等待成功或失败之后再调用。")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("class MyPromise {\n    constructor(executor) {\n        executor(this.resolve, this.reject)\n    }\n    // promise 状态\n    status = PENDING;\n    // 成功之后的值\n    value = undefined;\n    // 失败之后的值\n    reason = undefined\n    // 成功回调\n    successCallback = undefined;\n    // 失败回调\n    failCallback = undefined;\n\n    resolve = (value) => {\n        if(this.status !== PENDING) return;\n        // 将状态更改为成功\n        this.status = FULFILLED;\n        // 保存成功之后的值\n        this.value = value\n        // 判断成功回调是否存在，如果存在调用\n        this.successCallback && this.successCallback(this.value)\n    }\n\n    reject = (reason) => {\n        if(this.status !== PENDING) return;\n        // 将状态更改为失败\n        this.status = REJECTED;\n        this.reason = reason;\n        // 判断失败回调是否存在，如果存在调用\n        this.failCallback && this.failCallback(this.value)\n    }\n\n    then = (successCallback, failCallback) => {\n        // 判断状态\n        if(this.status === FULFILLED) {\n            successCallback(this.value);\n        } else if(this.status === REJECTED) {\n            failCallback(this.reason);\n        } else {\n            // 等待\n            // 将成功回调和失败回调存储起来\n            this.successCallback = successCallback;\n            this.failCallback = failCallback;\n        }\n    }\n}\n\n")])])]),s("h2",{attrs:{id:"then-添加多个处理函数"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#then-添加多个处理函数"}},[e._v("#")]),e._v(" then 添加多个处理函数")]),e._v(" "),s("p",[e._v("目前"),s("code",[e._v("Promise")]),e._v("只支持一个 then 方法。")]),e._v(" "),s("p",[e._v("实现 "),s("code",[e._v("then")]),e._v(" 添加多个处理函数，将 "),s("code",[e._v("this.successCallback")]),e._v(", "),s("code",[e._v("this.failCallback")]),e._v(" 变成数组")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("class MyPromise {\n    constructor(executor) {\n        executor(this.resolve, this.reject)\n    }\n    // promise 状态\n    status = PENDING;\n    // 成功之后的值\n    value = undefined;\n    // 失败之后的值\n    reason = undefined\n    // 成功回调\n    successCallback = [];\n    // 失败回调\n    failCallback = [];\n\n    resolve = (value) => {\n        if(this.status !== PENDING) return;\n        // 将状态更改为成功\n        this.status = FULFILLED;\n        // 保存成功之后的值\n        this.value = value\n        // 判断成功回调是否存在，如果存在调用\n        while(this.successCallback.length) this.successCallback.shift()(this.value);\n    }\n\n    reject = (reason) => {\n        if(this.status !== PENDING) return;\n        // 将状态更改为失败\n        this.status = REJECTED;\n        this.reason = reason;\n        // 判断失败回调是否存在，如果存在调用\n        while(this.failCallback.length) this.failCallback.shift()(this.reason);\n\n    }\n\n    then = (successCallback, failCallback) => {\n        // 判断状态\n        if(this.status === FULFILLED) {\n            successCallback(this.value);\n        } else if(this.status === REJECTED) {\n            failCallback(this.reason);\n        } else {\n            // 等待\n            // 将成功回调和失败回调存储起来\n            this.successCallback.push(successCallback);\n            this.failCallback.push(failCallback);\n        }\n    }\n}\n")])])]),s("h2",{attrs:{id:"then-方法的链式调用"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#then-方法的链式调用"}},[e._v("#")]),e._v(" then 方法的链式调用")]),e._v(" "),s("p",[e._v("实现 "),s("code",[e._v("then")]),e._v(" 方法的链式调用，并将 "),s("code",[e._v("then")]),e._v(" 方法的返回值传递给下一个 "),s("code",[e._v("then")]),e._v(" 方法")]),e._v(" "),s("ul",[s("li",[e._v("将 "),s("code",[e._v("then")]),e._v("返回一个 promise 对象，判断回调函数返回的是普通值还是 promise 对象")]),e._v(" "),s("li",[e._v("当 "),s("code",[e._v("promise.then")]),e._v(" 返回和自身相同的 "),s("code",[e._v("promise")]),e._v(" 抛出错误")])]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("class MyPromise {\n    constructor(executor) {\n        executor(this.resolve, this.reject)\n    }\n    // promise 状态\n    status = PENDING;\n    // 成功之后的值\n    value = undefined;\n    // 失败之后的值\n    reason = undefined\n    // 成功回调\n    successCallback = [];\n    // 失败回调\n    failCallback = [];\n\n    resolve = (value) => {\n        if(this.status !== PENDING) return;\n        // 将状态更改为成功\n        this.status = FULFILLED;\n        // 保存成功之后的值\n        this.value = value\n        // 判断成功回调是否存在，如果存在调用\n        while(this.successCallback.length) this.successCallback.shift()(this.value);\n    }\n\n    reject = (reason) => {\n        if(this.status !== PENDING) return;\n        // 将状态更改为失败\n        this.status = REJECTED;\n        this.reason = reason;\n        // 判断失败回调是否存在，如果存在调用\n        while(this.failCallback.length) this.failCallback.shift()(this.reason);\n\n    }\n\n    then = (successCallback, failCallback) => {\n        let promise2 = new MyPromise((resolve, reject) => {\n            // 判断状态\n            if(this.status === FULFILLED) {\n                // 变成异步代码，等promise2主流程执行完后再调用，可获取promise2\n                setTimeout(() => {\n                    let x = successCallback(this.value);\n                    // 判断x的值是普通值还是promise对象\n                    // 如果是普通值 直接调用resolve\n                    // 如果是promise对象 查看promise对象的返回结果\n                    // 再根据promise对象的返回据结果决定调用resolve还是调用reject\n                    resolvePromise(promise2, x, resolve, reject)\n                }, 0);\n\n            } else if(this.status === REJECTED) {\n                failCallback(this.reason);\n            } else {\n                // 等待\n                // 将成功回调和失败回调存储起来\n                this.successCallback.push(successCallback);\n                this.failCallback.push(failCallback);\n            }\n        })\n\n        return promise2;\n    }\n}\n\nfunction resolvePromise(promise2, x, resolve, reject) {\n    // 当promise.then 返回和自身相同promise报错\n    if(promise2 === x) {\n        return reject(new TypeError('Chaining cycle detected for promise #<Promise>'))\n    }\n    if(x instanceof MyPromise) {\n        x.then(resolve, reject)\n    } else {\n        // 普通值\n        resolve(x)\n    }\n}\n")])])]),s("h2",{attrs:{id:"捕获错误-then-方法完善"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#捕获错误-then-方法完善"}},[e._v("#")]),e._v(" 捕获错误 & then 方法完善")]),e._v(" "),s("ul",[s("li",[e._v("在执行器和回调函数添加 try catch 异常捕获，当发成错误是则直接调用 reject")]),e._v(" "),s("li",[e._v("将 then 方法的参数变成可选参数\n"),s("ul",[s("li",[e._v("promise.then().then().then(value => console.log(value)) 最后的"),s("code",[e._v("then")]),e._v("方法的 value 可以接收到 promise 的返回值")])])])]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("class MyPromise {\n    constructor(executor) {\n        try {\n            executor(this.resolve, this.reject)\n        } catch(e) {\n            this.reject(e)\n        }\n    }\n\n    // promise 状态\n    status = PENDING;\n    // 成功之后的值\n    value = undefined;\n    // 失败之后的值\n    reason = undefined\n    // 成功回调\n    successCallback = [];\n    // 失败回调\n    failCallback = [];\n\n    resolve = (value) => {\n        if(this.status !== PENDING) return;\n        // 将状态更改为成功\n        this.status = FULFILLED;\n        // 保存成功之后的值\n        this.value = value\n        // 判断成功回调是否存在，如果存在调用\n        while(this.successCallback.length) this.successCallback.shift()();\n    }\n\n    reject = (reason) => {\n        if(this.status !== PENDING) return;\n        // 将状态更改为失败\n        this.status = REJECTED;\n        this.reason = reason;\n        // 判断失败回调是否存在，如果存在调用\n        while(this.failCallback.length) this.failCallback.shift()();\n\n    }\n\n    then = (successCallback, failCallback) => {\n        successCallback = successCallback || (value => value);\n        failCallback = failCallback || (reason => {throw reason});\n\n        let promise2 = new MyPromise((resolve, reject) => {\n            // 判断状态\n            if(this.status === FULFILLED) {\n                // 变成异步代码，等promise2主流程执行完后再调用，可获取promise2\n                setTimeout(() => {\n                    try {\n                        let x = successCallback(this.value);\n                        // 判断x的值是普通值还是promise对象\n                        // 如果是普通值 直接调用resolve\n                        // 如果是promise对象 查看promise对象的返回结果\n                        // 再根据promise对象的返回据结果决定调用resolve还是调用reject\n                        resolvePromise(promise2, x, resolve, reject)\n                    } catch (e) {\n                        reject(e)\n                    }\n\n                }, 0);\n\n            } else if(this.status === REJECTED) {\n                setTimeout(() => {\n                    try {\n                        let x = failCallback(this.reason);\n                        // 判断x的值是普通值还是promise对象\n                        // 如果是普通值 直接调用resolve\n                        // 如果是promise对象 查看promise对象的返回结果\n                        // 再根据promise对象的返回据结果决定调用resolve还是调用reject\n                        resolvePromise(promise2, x, resolve, reject)\n                    } catch (e) {\n                        reject(e)\n                    }\n\n                }, 0);\n\n            } else {\n                // 等待\n                // 将成功回调和失败回调存储起来\n                this.successCallback.push(() => {\n                    setTimeout(() => {\n                        try {\n                            let x = successCallback(this.value);\n                            // 判断x的值是普通值还是promise对象\n                            // 如果是普通值 直接调用resolve\n                            // 如果是promise对象 查看promise对象的返回结果\n                            // 再根据promise对象的返回据结果决定调用resolve还是调用reject\n                            resolvePromise(promise2, x, resolve, reject)\n                        } catch (e) {\n                            reject(e)\n                        }\n\n                    }, 0);\n                });\n                this.failCallback.push(() => {\n                    setTimeout(() => {\n                        try {\n                            let x = failCallback(this.reason);\n                            // 判断x的值是普通值还是promise对象\n                            // 如果是普通值 直接调用resolve\n                            // 如果是promise对象 查看promise对象的返回结果\n                            // 再根据promise对象的返回据结果决定调用resolve还是调用reject\n                            resolvePromise(promise2, x, resolve, reject)\n                        } catch (e) {\n                            reject(e)\n                        }\n\n                    }, 0);\n                });\n            }\n        })\n\n        return promise2;\n    }\n}\n\nfunction resolvePromise(promise2, x, resolve, reject) {\n    // 当promise.then 返回和自身相同promise报错\n    if(promise2 === x) {\n        return reject(new TypeError('Chaining cycle detected for promise #<Promise>'))\n    }\n\n    if(x instanceof MyPromise) {\n        x.then(resolve, reject)\n    } else {\n        // 普通值\n        resolve(x)\n    }\n}\n")])])]),s("h2",{attrs:{id:"添加方法-完善-promise-功能"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#添加方法-完善-promise-功能"}},[e._v("#")]),e._v(" 添加方法，完善 promise 功能")]),e._v(" "),s("p",[e._v("给 MyPromise 类添加"),s("code",[e._v("all")]),e._v("和"),s("code",[e._v("resolve")]),e._v("静态方法，和"),s("code",[e._v("catch")]),e._v("和"),s("code",[e._v("finally")]),e._v("方法，完善 promise 功能，使其更接近真实的 Promise 类，这样我们自己 Promise 类就大功告成了")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("const PENDING = 'pending'; // 等待\nconst FULFILLED = 'fullilled' // 成功\nconst REJECTED = 'rejected' // 失败\n\nclass MyPromise {\n    constructor(executor) {\n        try {\n            executor(this.resolve, this.reject)\n        } catch(e) {\n            this.reject(e)\n        }\n    }\n\n    // promise 状态\n    status = PENDING;\n    // 成功之后的值\n    value = undefined;\n    // 失败之后的值\n    reason = undefined\n    // 成功回调\n    successCallback = [];\n    // 失败回调\n    failCallback = [];\n\n    resolve = (value) => {\n        if(this.status !== PENDING) return;\n        // 将状态更改为成功\n        this.status = FULFILLED;\n        // 保存成功之后的值\n        this.value = value\n        // 判断成功回调是否存在，如果存在调用\n        while(this.successCallback.length) this.successCallback.shift()();\n    }\n\n    reject = (reason) => {\n        if(this.status !== PENDING) return;\n        // 将状态更改为失败\n        this.status = REJECTED;\n        this.reason = reason;\n        // 判断失败回调是否存在，如果存在调用\n        while(this.failCallback.length) this.failCallback.shift()();\n\n    }\n\n    then = (successCallback, failCallback) => {\n        successCallback = successCallback || (value => value);\n        failCallback = failCallback || (reason => {throw reason});\n\n        let promise2 = new MyPromise((resolve, reject) => {\n            // 判断状态\n            if(this.status === FULFILLED) {\n                // 变成异步代码，等promise2主流程执行完后再调用，可获取promise2\n                setTimeout(() => {\n                    try {\n                        let x = successCallback(this.value);\n                        // 判断x的值是普通值还是promise对象\n                        // 如果是普通值 直接调用resolve\n                        // 如果是promise对象 查看promise对象的返回结果\n                        // 再根据promise对象的返回据结果决定调用resolve还是调用reject\n                        resolvePromise(promise2, x, resolve, reject)\n                    } catch (e) {\n                        reject(e)\n                    }\n\n                }, 0);\n\n            } else if(this.status === REJECTED) {\n                setTimeout(() => {\n                    try {\n                        let x = failCallback(this.reason);\n                        // 判断x的值是普通值还是promise对象\n                        // 如果是普通值 直接调用resolve\n                        // 如果是promise对象 查看promise对象的返回结果\n                        // 再根据promise对象的返回据结果决定调用resolve还是调用reject\n                        resolvePromise(promise2, x, resolve, reject)\n                    } catch (e) {\n                        reject(e)\n                    }\n\n                }, 0);\n\n            } else {\n                // 等待\n                // 将成功回调和失败回调存储起来\n                this.successCallback.push(() => {\n                    setTimeout(() => {\n                        try {\n                            let x = successCallback(this.value);\n                            // 判断x的值是普通值还是promise对象\n                            // 如果是普通值 直接调用resolve\n                            // 如果是promise对象 查看promise对象的返回结果\n                            // 再根据promise对象的返回据结果决定调用resolve还是调用reject\n                            resolvePromise(promise2, x, resolve, reject)\n                        } catch (e) {\n                            reject(e)\n                        }\n\n                    }, 0);\n                });\n                this.failCallback.push(() => {\n                    setTimeout(() => {\n                        try {\n                            let x = failCallback(this.reason);\n                            // 判断x的值是普通值还是promise对象\n                            // 如果是普通值 直接调用resolve\n                            // 如果是promise对象 查看promise对象的返回结果\n                            // 再根据promise对象的返回据结果决定调用resolve还是调用reject\n                            resolvePromise(promise2, x, resolve, reject)\n                        } catch (e) {\n                            reject(e)\n                        }\n\n                    }, 0);\n                });\n            }\n        })\n\n        return promise2;\n    }\n    // 无论结果返回成功还是失败都要调用一次\n    finally(callback) {\n        // 通过then方法得到当前promise的状态\n        return this.then(value => {\n            return MyPromise.resolve(callback()).then(() => value)\n        }, reason => {\n            return MyPromise.resolve(callback()).then(() => {throw reason})\n        })\n    }\n\n    catch(failCallback) {\n        return this.then(undefined, failCallback)\n    }\n\n    static all(array) {\n        let result = [];\n        let index = 0\n\n        return new MyPromise((resolve, reject) => {\n            function addData(key, value) {\n                result[key] = value\n                index++\n                if(index === array.length) {\n                    resolve(result);\n                }\n            }\n\n            for(let i = 0; i < array.length; i++) {\n                let current = array[i];\n                if(current instanceof MyPromise) {\n                    // promise对象\n                    current.then(value => addData(i, value), reason => reject(reason))\n                } else {\n                    // 普通值\n                    addData(i, array[i])\n                }\n            }\n        })\n    }\n\n    static resolve(value) {\n        if(value instanceof MyPromise) return value;\n        return new MyPromise(resolve => resolve(value))\n    }\n}\n\nfunction resolvePromise(promise2, x, resolve, reject) {\n    // 当promise.then 返回和自身相同promise报错\n    if(promise2 === x) {\n        return reject(new TypeError('Chaining cycle detected for promise #<Promise>'))\n    }\n    if(x instanceof MyPromise) {\n        x.then(resolve, reject)\n    } else {\n        // 普通值\n        resolve(x)\n    }\n}\n\n")])])])])}),[],!1,null,null,null);n.default=a.exports}}]);