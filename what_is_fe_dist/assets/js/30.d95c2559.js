(window.webpackJsonp=window.webpackJsonp||[]).push([[30],{397:function(a,t,n){"use strict";n.r(t);var r=n(27),e=Object(r.a)({},(function(){var a=this,t=a.$createElement,n=a._self._c||t;return n("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[n("h1",{attrs:{id:"javasript-性能优化"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#javasript-性能优化"}},[a._v("#")]),a._v(" JavaSript 性能优化")]),a._v(" "),n("h2",{attrs:{id:"javacript-内存管理"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#javacript-内存管理"}},[a._v("#")]),a._v(" Javacript 内存管理")]),a._v(" "),n("ul",[n("li",[n("strong",[a._v("内存")]),a._v(": 有可读写的单元组成，表示一片可操作的空间")]),a._v(" "),n("li",[n("strong",[a._v("内存管理")]),a._v("： 开发者主动申请空间，使用空间，释放空间")])]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("  // 申请\n  let obj = {}\n  // 使用\n  obj.name = 'lg'\n  // 释放\n  obj = null\n")])])]),n("h2",{attrs:{id:"javacript-垃圾回收"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#javacript-垃圾回收"}},[a._v("#")]),a._v(" Javacript 垃圾回收")]),a._v(" "),n("p",[a._v("JavaScript 中"),n("strong",[a._v("内存管理")]),a._v("是自动的，而且是不可见的。我们创建基本类型、对象、函数……所有这些都需要内存。")]),a._v(" "),n("h3",{attrs:{id:"什么时候产生垃圾"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#什么时候产生垃圾"}},[a._v("#")]),a._v(" 什么时候产生垃圾")]),a._v(" "),n("ul",[n("li",[a._v("对象不在被引用时")]),a._v(" "),n("li",[a._v("对象不能从跟上访问到")])]),a._v(" "),n("h3",{attrs:{id:"可达对象"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#可达对象"}},[a._v("#")]),a._v(" 可达对象")]),a._v(" "),n("ul",[n("li",[a._v("可以被访问到的对象就是"),n("strong",[a._v("可达对象")]),a._v("（引用，作用域链）")]),a._v(" "),n("li",[a._v("可达的标准就是从"),n("strong",[a._v("跟")]),a._v("上出发是否能够被找到")]),a._v(" "),n("li",[a._v("JavaScript 中的"),n("strong",[a._v("根")]),a._v("就可以理解为是"),n("strong",[a._v("全局变量对象")])])]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("function objGroup(obj1, obj2) {\n    obj1.next = obj2\n    obj2.prev = obj1\n\n    return {\n        o1: obj1,\n        o2: obj2\n    }\n}\n\nlet obj = objGroup({name: 'obj1'}, {name: 'obj2'})\nconsole.log(obj)\n")])])]),n("p",[a._v("使用图示对上面代码进行说明，obj1 和 obj2 进行相互的引用，目前所有对象都是可达对象。")]),a._v(" "),n("p",[n("img",{attrs:{src:"/running-monitoring/%E5%8F%AF%E8%BE%BE%E5%AF%B9%E8%B1%A11.png",alt:""}})]),a._v(" "),n("p",[a._v("当把 obj 下的 o1 和 o2 的 prev 删除掉，此时我们无法访问到 obj1,这时可以 obj1 可以被认为是"),n("strong",[a._v("垃圾")])]),a._v(" "),n("p",[n("img",{attrs:{src:"/running-monitoring/%E5%8F%AF%E8%BE%BE%E5%AF%B9%E8%B1%A12.png",alt:""}})]),a._v(" "),n("p",[a._v("JavaScript 引擎中有一个后台进程称为垃圾回收器，它监视所有对象，并删除那些不可访问的对象。")]),a._v(" "),n("h2",{attrs:{id:"gc-算法"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#gc-算法"}},[a._v("#")]),a._v(" GC 算法")]),a._v(" "),n("p",[a._v("GC 就是"),n("strong",[a._v("垃圾回收机制")]),a._v("的简写，GC 可以找到内存中的垃圾、并释放和回收空间")]),a._v(" "),n("p",[n("strong",[a._v("GC 里的垃圾是什么？")])]),a._v(" "),n("ul",[n("li",[a._v("程序中不再需要使用的对象")]),a._v(" "),n("li",[a._v("程序中不能在访问的对象")])]),a._v(" "),n("p",[n("strong",[a._v("什么是 GC 算法？")])]),a._v(" "),n("ul",[n("li",[a._v("GC 是一种机制，垃圾回收完成具体的工作")]),a._v(" "),n("li",[a._v("工作内容就是查找垃圾释放空间、回收空间")]),a._v(" "),n("li",[a._v("算法就是工作是查找和回收所遵循的原则")])]),a._v(" "),n("h3",{attrs:{id:"引用计数"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#引用计数"}},[a._v("#")]),a._v(" 引用计数")]),a._v(" "),n("p",[a._v("这是最初级的垃圾收集算法。此算法把“对象是否不再需要”简化定义为“对象有没有其他对象引用到它”。如果没有引用指向该对象（零引用），对象将被垃圾回收机制回收。")]),a._v(" "),n("p",[n("strong",[a._v("核心思想")])]),a._v(" "),n("p",[a._v("设置引用数， 判断当前引用数是否为 0")]),a._v(" "),n("p",[n("strong",[a._v("示例")])]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v('var o = {\n  a: {\n    b:2\n  }\n};\n// 两个对象被创建，一个作为另一个的属性被引用，另一个被分配给变量o\n// 很显然，没有一个可以被垃圾收集\n\n\nvar o2 = o; // o2变量是第二个对“这个对象”的引用\n\no = 1;      // 现在，“这个对象”只有一个o2变量的引用了，“这个对象”的原始引用o已经没有\n\nvar oa = o2.a; // 引用“这个对象”的a属性\n               // 现在，“这个对象”有两个引用了，一个是o2，一个是oa\n\no2 = "yo"; // 虽然最初的对象现在已经是零引用了，可以被垃圾回收了\n           // 但是它的属性a的对象还在被oa引用，所以还不能回收\n\noa = null; // a属性的那个对象现在也是零引用了\n           // 它可以被垃圾回收了\n')])])]),n("p",[n("strong",[a._v("优点")])]),a._v(" "),n("ul",[n("li",[a._v("可以及时回收垃圾对象")]),a._v(" "),n("li",[a._v("减少程序卡顿")])]),a._v(" "),n("p",[n("strong",[a._v("缺点")])]),a._v(" "),n("ul",[n("li",[a._v("无法回收循环引用的对象")]),a._v(" "),n("li",[a._v("资源消耗比较大")])]),a._v(" "),n("h3",{attrs:{id:"标记清除"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#标记清除"}},[a._v("#")]),a._v(" 标记清除")]),a._v(" "),n("p",[a._v("这个算法假定设置一个叫做**根（root）**的对象（在 Javascript 里，根是全局对象）。垃圾回收器将定期从根开始，找所有从根开始引用的对象，然后找这些对象引用的对象……从根开始，垃圾回收器将找到所有可以获得的对象和收集所有不能获得的对象。")]),a._v(" "),n("p",[a._v("如图所示，a1 和 b1 相互引用，但是无法从"),n("strong",[a._v("跟")]),a._v("上访问到，为不可达对象，所以被当做垃圾处理。")]),a._v(" "),n("p",[n("img",{attrs:{src:"/running-monitoring/%E6%A0%87%E8%AE%B0%E6%B8%85%E9%99%A4.png",alt:""}})]),a._v(" "),n("p",[n("strong",[a._v("核心思想")])]),a._v(" "),n("p",[a._v("核心思想：分"),n("strong",[a._v("标记")]),a._v("和"),n("strong",[a._v("清除")]),a._v("两个阶段，第一阶段遍历所有对象找标记活动对象，遍历所有对象清除没有标记对象。")]),a._v(" "),n("p",[n("strong",[a._v("优点")])]),a._v(" "),n("ul",[n("li",[a._v("可以回收循环引用的对象")])]),a._v(" "),n("p",[n("strong",[a._v("缺点")])]),a._v(" "),n("ul",[n("li",[a._v("容易产生碎片化空间，浪费空间")]),a._v(" "),n("li",[a._v("不会立即回收垃圾对象")])]),a._v(" "),n("h3",{attrs:{id:"标记整理"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#标记整理"}},[a._v("#")]),a._v(" 标记整理")]),a._v(" "),n("p",[a._v("标记整理算法是"),n("strong",[a._v("标记清除")]),a._v("的增强，会在清除阶段之前执行整理，移动对象位置。")]),a._v(" "),n("p",[n("strong",[a._v("优点")])]),a._v(" "),n("ul",[n("li",[a._v("减少碎片化空间")])]),a._v(" "),n("p",[n("strong",[a._v("缺点")])]),a._v(" "),n("ul",[n("li",[a._v("不会立即回收垃圾对象")])]),a._v(" "),n("h2",{attrs:{id:"v8-引擎"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#v8-引擎"}},[a._v("#")]),a._v(" V8 引擎")]),a._v(" "),n("p",[a._v("V8 引擎是一款主流的采用即时编译的 JavScript 执行引擎")]),a._v(" "),n("h3",{attrs:{id:"v8-内存设限"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#v8-内存设限"}},[a._v("#")]),a._v(" V8 内存设限")]),a._v(" "),n("p",[a._v("由于起初只是作为浏览器端 JavaScript 的执行环境，且 JavaScript 是单线程的，在浏览器端我们很少会遇到使用大量内存的场景，所以 V8 直接对内存进行了限制。64 位操作系统默认使用 1.4G，32 位操作系统默认使用 0.7G。")]),a._v(" "),n("h3",{attrs:{id:"v8-垃圾回收策略"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#v8-垃圾回收策略"}},[a._v("#")]),a._v(" V8 垃圾回收策略")]),a._v(" "),n("p",[a._v("V8 采用了一种分代回收的策略，将内存分为两个生代：新生代（new generation）和老生代（old generation）, 针对不同对象采用不同算法。")]),a._v(" "),n("p",[n("img",{attrs:{src:"/running-monitoring/v8%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6.png",alt:""}})]),a._v(" "),n("p",[a._v("v8 内部内存被分为两个区域，左侧存储老生代对象，右侧存储老生代对象\n"),n("img",{attrs:{src:"/running-monitoring/v8%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D.png",alt:""}})]),a._v(" "),n("h3",{attrs:{id:"新生代垃圾回收"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#新生代垃圾回收"}},[a._v("#")]),a._v(" 新生代垃圾回收")]),a._v(" "),n("p",[n("strong",[a._v("新生代")]),a._v("指的是存活时间较短的对象")]),a._v(" "),n("p",[a._v("回收过程采用复制算法和标记整理，新生代内存区分为两个等大小的空间 From（使用空间）和 To（空闲空间）")]),a._v(" "),n("p",[a._v("活动对象存储在 From 空间，当垃圾回收时使用标记整理后将活动对象拷贝至 To，然后 From 和 To 交换空间完成释放")]),a._v(" "),n("p",[a._v("新生代区域垃圾回收使用空间换时间。")]),a._v(" "),n("p",[a._v("拷贝的过程中可能存在"),n("strong",[a._v("晋升")]),a._v("，"),n("strong",[a._v("晋升")]),a._v("就是将新生代对象移动至老年代")]),a._v(" "),n("p",[n("strong",[a._v("晋升条件")])]),a._v(" "),n("ul",[n("li",[a._v("一轮 GC 还存活的新生态对象需要晋升")]),a._v(" "),n("li",[a._v("To 空间的使用率超过 25%")])]),a._v(" "),n("h3",{attrs:{id:"老生代垃圾回收"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#老生代垃圾回收"}},[a._v("#")]),a._v(" 老生代垃圾回收")]),a._v(" "),n("p",[n("strong",[a._v("老生代")]),a._v("指的是存活时间较长的对象，例如全局对象和闭包里的数据。")]),a._v(" "),n("p",[a._v("回收过程采用标记清除、标记整理、增量标记算法，首先使用"),n("strong",[a._v("标记清除")]),a._v("完成垃圾空间的回收，然后在"),n("strong",[a._v("晋升")]),a._v("阶段如果空间不足采用"),n("strong",[a._v("标记整理")]),a._v("进行空间优化，采用"),n("strong",[a._v("增量标记")]),a._v("进行效率的优化")]),a._v(" "),n("p",[n("strong",[a._v("增量标记如何优化垃圾回收")])]),a._v(" "),n("p",[a._v("原本需要一次性遍历堆内存的操作改为增量标记的方式，先标记堆内存中的一部分对象，然后暂停，将执行权重新交给 JS 主线程，待主线程任务执行完毕后再从原来暂停标记的地方继续标记，直到标记完整个堆内存。这个理念其实有点像"),n("strong",[a._v("React")]),a._v("框架中的"),n("strong",[a._v("Fiber")]),a._v("架构，只有在浏览器的空闲时间才会去遍历"),n("strong",[a._v("Fiber")]),a._v(" Tree 执行对应的任务，否则延迟执行，尽可能少地影响主线程的任务，避免应用卡顿，提升应用性能。")]),a._v(" "),n("p",[n("img",{attrs:{src:"/running-monitoring/%E5%A2%9E%E9%87%8F%E6%A0%87%E8%AE%B0.png",alt:""}})]),a._v(" "),n("h2",{attrs:{id:"performance-工具"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#performance-工具"}},[a._v("#")]),a._v(" Performance 工具")]),a._v(" "),n("p",[a._v("使用 Chrome DevTools 的 "),n("strong",[a._v("performance")]),a._v(" 面板可以记录和分析页面在"),n("strong",[a._v("运行时")]),a._v("的所有活动,通过 Performance 可以时刻监控内存。")]),a._v(" "),n("p",[a._v("可以参考"),n("a",{attrs:{href:"https://zhuanlan.zhihu.com/p/29879682",target:"_blank",rel:"noopener noreferrer"}},[a._v("Chrome Devtool Performance 使用指南"),n("OutboundLink")],1)]),a._v(" "),n("h2",{attrs:{id:"内存问题"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#内存问题"}},[a._v("#")]),a._v(" 内存问题")]),a._v(" "),n("h3",{attrs:{id:"外在表现"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#外在表现"}},[a._v("#")]),a._v(" 外在表现")]),a._v(" "),n("ul",[n("li",[a._v("页面出现延迟加载或经常性暂停")]),a._v(" "),n("li",[a._v("页面持续性出现糟糕的性能")]),a._v(" "),n("li",[a._v("页面的性能随时间延长越来越差（内存泄露）")])]),a._v(" "),n("h3",{attrs:{id:"界定内存问题的标准"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#界定内存问题的标准"}},[a._v("#")]),a._v(" 界定内存问题的标准")]),a._v(" "),n("ul",[n("li",[n("strong",[a._v("内存泄漏（memory leak）")]),a._v(": 不再用到的内存，没有及时释放，内存使用持续升高\n"),n("img",{attrs:{src:"/running-monitoring/%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2.png",alt:""}})]),a._v(" "),n("li",[n("strong",[a._v("内存膨胀")]),a._v(": 在多数设备上都存在性能问题")]),a._v(" "),n("li",[n("strong",[a._v("频繁垃圾回收")]),a._v(": 通过内存变化图进行分析")])]),a._v(" "),n("h3",{attrs:{id:"监控内存的几种方式"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#监控内存的几种方式"}},[a._v("#")]),a._v(" 监控内存的几种方式")]),a._v(" "),n("ul",[n("li",[a._v("浏览器的任务管理器")]),a._v(" "),n("li",[a._v("Timeline 时序图记录")]),a._v(" "),n("li",[a._v("堆快照查找分离 DOM")])]),a._v(" "),n("h3",{attrs:{id:"任务管理器监控内存"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#任务管理器监控内存"}},[a._v("#")]),a._v(" 任务管理器监控内存")]),a._v(" "),n("p",[a._v("可以通过判断内存是否增长来判断是否有问题，不能定位问题。")]),a._v(" "),n("h3",{attrs:{id:"timeline-时序图记录"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#timeline-时序图记录"}},[a._v("#")]),a._v(" Timeline 时序图记录")]),a._v(" "),n("p",[a._v("使用 Performance 工具，勾选内存选项，来分析内存的实时走向\n"),n("img",{attrs:{src:"/running-monitoring/timeline.png",alt:""}})]),a._v(" "),n("h3",{attrs:{id:"堆快照查找分离-dom"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#堆快照查找分离-dom"}},[a._v("#")]),a._v(" 堆快照查找分离 DOM")]),a._v(" "),n("p",[n("strong",[a._v("什么是分离 DOM")])]),a._v(" "),n("p",[n("strong",[a._v("分离 DOM")]),a._v("从 DOM 树上分离，但是在 JS 代码中还有引用，在界面上看不见，在内存上占据空间。")]),a._v(" "),n("p",[a._v("以下代码 tmpEle 为"),n("strong",[a._v("分离 DOM")])]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("  var tmpEle;\n  function fn() {\n    var ul = document.createElement('ul');\n    for(var i = 0; i < 10; i++) {\n      var li = document.createElement('li');\n      ul.appendChild(li)\n\n      tmpEle = ul;\n    }\n  }\n")])])]),n("p",[a._v("使用开发者工具 内存， 勾选堆快照\n"),n("img",{attrs:{src:"/running-monitoring/%E5%A0%86%E5%BF%AB%E7%85%A7.png",alt:""}})]),a._v(" "),n("p",[a._v("搜索 detached 查看是否有分离 dom\n"),n("img",{attrs:{src:"/running-monitoring/%E5%A0%86%E5%BF%AB%E7%85%A7%E5%88%86%E7%A6%BBdom.png",alt:""}})]),a._v(" "),n("h2",{attrs:{id:"js-代码优化"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#js-代码优化"}},[a._v("#")]),a._v(" JS 代码优化")]),a._v(" "),n("h3",{attrs:{id:"慎用全局变量"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#慎用全局变量"}},[a._v("#")]),a._v(" 慎用全局变量")]),a._v(" "),n("p",[n("strong",[a._v("全局变量")]),a._v("定义在全局的执行上下文，是所有作用域链的顶端")]),a._v(" "),n("p",[n("strong",[a._v("为什么要慎用？")])]),a._v(" "),n("ul",[n("li",[a._v("全局执行上下文一直存在于上下文执行栈，直到程序退出，不利于垃圾回收")]),a._v(" "),n("li",[a._v("如果某个局部作用域出现了同名变量则会遮蔽或污染全局")])]),a._v(" "),n("p",[a._v("使用 "),n("a",{attrs:{href:"https://jsbench.me/",target:"_blank",rel:"noopener noreferrer"}},[a._v("jsbench"),n("OutboundLink")],1),a._v(" 对代码的效率进行对比")]),a._v(" "),n("p",[n("img",{attrs:{src:"/running-monitoring/jsbench1.png",alt:""}})]),a._v(" "),n("h3",{attrs:{id:"通过原型对象添加附加方法"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#通过原型对象添加附加方法"}},[a._v("#")]),a._v(" 通过原型对象添加附加方法")]),a._v(" "),n("p",[n("img",{attrs:{src:"/running-monitoring/jsbench2.png",alt:""}})]),a._v(" "),n("h3",{attrs:{id:"避开闭包陷阱"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#避开闭包陷阱"}},[a._v("#")]),a._v(" 避开闭包陷阱")]),a._v(" "),n("p",[n("strong",[a._v("闭包特点")])]),a._v(" "),n("ul",[n("li",[a._v("外部具有指向内部的引用")]),a._v(" "),n("li",[a._v("在外部作用域访问内部作用域的数据")])]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("  // 此时的a引用了内部的fn\n  // a在调用时外部作用域访问了内部的a\n  // 发生了闭包\n  function foo() {\n    let name = 'licop';\n\n    return function fn() {\n      console.log(name)\n    }\n  }\n\n  var a = foo()\n  a();\n")])])]),n("p",[a._v("闭包是一个强大的语法，闭包使用不当很容易造成出现内存泄露，不要为了闭包而闭包。")]),a._v(" "),n("h3",{attrs:{id:"避免属性访问方法使用"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#避免属性访问方法使用"}},[a._v("#")]),a._v(" 避免属性访问方法使用")]),a._v(" "),n("p",[n("img",{attrs:{src:"/running-monitoring/jsbench3.png",alt:""}})]),a._v(" "),n("h3",{attrs:{id:"for-循环优化"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#for-循环优化"}},[a._v("#")]),a._v(" for 循环优化")]),a._v(" "),n("p",[n("strong",[a._v("对数组的长度进行提前保存, 减少循环体中的活动")])]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("  for(var i = 0; i < arr.length; i++) {\n    console.log(i)\n  }\n\n  // 更优\n  let let =  arr.length\n  for(var i = 0; i < len; i++) {\n    console.log(i)\n  }\n")])])]),n("p",[n("strong",[a._v("对比遍历方式")])]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("var arrList = new Array(1, 2, 3, 4, 5)\n\n// 最快\narrList.forEach(function(item) {\n  console.log(item)\n})\n\n// 相对较慢\nfor (var i = arrList.length; i; i--) {\n  console.log(arrList[i])\n}\n\n// 很快\nfor (var i in arrList) {\n  console.log(arrList[i])\n}\n")])])]),n("h3",{attrs:{id:"优化节点操作"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#优化节点操作"}},[a._v("#")]),a._v(" 优化节点操作")]),a._v(" "),n("p",[a._v("通过文档碎片优化节点添加")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("for (var i = 0; i < 10; i++) {\n  var oP = document.createElement('p')\n  oP.innerHTML = i\n  document.body.appendChild(oP)\n}\n\n// 相对较快\nconst fragEle = document.createDocumentFragment()\nfor (var i = 0; i < 10; i++) {\n  var oP = document.createElement('p')\n  oP.innerHTML = i\n  fragEle.appendChild(oP)\n}\n\ndocument.body.appendChild(fragEle)\n")])])]),n("p",[a._v("通过克隆节点优化节点操作")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("for (var i = 0; i < 3; i++) {\n  var oP = document.createElement('p')\n  oP.innerHTML = i\n  document.body.appendChild(oP)\n}\n// 相对较快\nvar oldP = document.getElementById('box1')\nfor (var i = 0; i < 3; i++) {\n  var newP = oldP.cloneNode(false)\n  newP.innerHTML = i\n  document.body.appendChild(newP)\n}\n")])])]),n("h3",{attrs:{id:"直接量替换-new-object-构造式"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#直接量替换-new-object-构造式"}},[a._v("#")]),a._v(" 直接量替换 new object 构造式")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("// 较快\nvar a = [1, 2, 3]\n\n// 较慢\nvar a1 = new Array(3)\na1[0] = 1\na1[1] = 2\na1[2] = 3\n")])])]),n("h3",{attrs:{id:"减少判断层级"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#减少判断层级"}},[a._v("#")]),a._v(" 减少判断层级")]),a._v(" "),n("p",[a._v("尽量减少 if 语句的层级嵌套，可以使用提前 return 方法将嵌套减少掉")]),a._v(" "),n("h3",{attrs:{id:"减少作用链查找层级"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#减少作用链查找层级"}},[a._v("#")]),a._v(" 减少作用链查找层级")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("var name = 'licop';\nfunction  foo() {\n    name = 'licop1' // 这里的name属于全局的\n\n    function baz() {\n        let age = 18;\n        console.log(name, age)\n    }\n    baz()\n}\nfoo()\n\n// 更优\nvar name = 'licop';\nfunction  foo() {\n    let name = 'licop1'\n\n    function baz() {\n        let age = 18;\n        console.log(name, age)\n    }\n    baz()\n}\nfoo()\n")])])]),n("h3",{attrs:{id:"减少数据读取次数"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#减少数据读取次数"}},[a._v("#")]),a._v(" 减少数据读取次数")]),a._v(" "),n("p",[a._v("把频繁使用的值提前缓存变量，使用空间换时间")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("var oBox = document.getElementById('skip');\nfunction hasEle(ele, cls) {\n  return ele.className === cls\n}\nhasEle(oBox, 'skip')\n\n// 更优\nvar oBox = document.getElementById('skip');\nfunction hasEle(ele, cls) {\n  var clsName = ele.className\n  return clsName === cls\n}\nhasEle(oBox, 'skip')\n")])])]),n("h3",{attrs:{id:"减少声明及语句数"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#减少声明及语句数"}},[a._v("#")]),a._v(" 减少声明及语句数")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("var test = (ele) = {\n  let w = ele.offsetWidth;\n  let h = ele.offsetHeight;\n  return w * h;\n}\n\n// 更优\nvar test = (ele) = {\n  return ele.offsetWidth * ele.offsetHeight;\n}\n\n")])])]),n("h3",{attrs:{id:"惰性函数与性能"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#惰性函数与性能"}},[a._v("#")]),a._v(" 惰性函数与性能")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("  function addEvent(obj, type, fn) {\n    if(obj.addEventListener) {\n      obj.addEventListener(type, fn, false)\n    } else if() {\n      obj.attachEvent('on' + type, fn)\n    } else {\n      obj['on' + type] = fn;\n    }\n  }\n  // 更优\n  function addEvent(obj, type, fn) {\n    if(obj.addEventListener) {\n      addEvent = obj.addEventListener(type, fn, false)\n    } else if() {\n      addEvent = obj.attachEvent('on' + type, fn)\n    } else {\n      addEvent = obj['on' + type] = fn;\n    }\n    return addEvent;\n  }\n\n  addEvent(btn, 'click', console.log(this))\n")])])]),n("h3",{attrs:{id:"采用事件绑定"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#采用事件绑定"}},[a._v("#")]),a._v(" 采用事件绑定")]),a._v(" "),n("h2",{attrs:{id:"更多参考"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#更多参考"}},[a._v("#")]),a._v(" 更多参考")]),a._v(" "),n("ul",[n("li",[n("a",{attrs:{href:"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Memory_Management",target:"_blank",rel:"noopener noreferrer"}},[a._v("MDN 内存管理"),n("OutboundLink")],1)]),a._v(" "),n("li",[n("a",{attrs:{href:"https://developers.google.com/web/tools/chrome-devtools/evaluate-performance?hl=zh-cn",target:"_blank",rel:"noopener noreferrer"}},[a._v("chrome Performance 的使用"),n("OutboundLink")],1)]),a._v(" "),n("li",[n("a",{attrs:{href:"https://zhuanlan.zhihu.com/p/29879682",target:"_blank",rel:"noopener noreferrer"}},[a._v("Chrome Devtool Performance 使用指南"),n("OutboundLink")],1)])])])}),[],!1,null,null,null);t.default=e.exports}}]);