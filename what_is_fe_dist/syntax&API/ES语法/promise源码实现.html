<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>promise 源码实现 | What is FE</title>
    <meta name="generator" content="VuePress 1.7.1">
    
    <meta name="description" content="构建自己的系统的 Web 前端知识体系">
    
    <link rel="preload" href="/assets/css/0.styles.41761744.css" as="style"><link rel="preload" href="/assets/js/app.2a46a431.js" as="script"><link rel="preload" href="/assets/js/2.5e2d37c1.js" as="script"><link rel="preload" href="/assets/js/32.47bddd0e.js" as="script"><link rel="preload" href="/assets/js/3.b304fdc1.js" as="script"><link rel="prefetch" href="/assets/js/10.9fc866c3.js"><link rel="prefetch" href="/assets/js/11.6cec0877.js"><link rel="prefetch" href="/assets/js/12.2e394fe4.js"><link rel="prefetch" href="/assets/js/13.37443924.js"><link rel="prefetch" href="/assets/js/14.e4ee4a94.js"><link rel="prefetch" href="/assets/js/15.61d3cd46.js"><link rel="prefetch" href="/assets/js/16.e1e700c5.js"><link rel="prefetch" href="/assets/js/17.7bdb8b53.js"><link rel="prefetch" href="/assets/js/18.77de363b.js"><link rel="prefetch" href="/assets/js/19.c944ea72.js"><link rel="prefetch" href="/assets/js/20.6e524740.js"><link rel="prefetch" href="/assets/js/21.cdd98e73.js"><link rel="prefetch" href="/assets/js/22.5db88245.js"><link rel="prefetch" href="/assets/js/23.0a0d000d.js"><link rel="prefetch" href="/assets/js/24.58c55955.js"><link rel="prefetch" href="/assets/js/25.97f845e6.js"><link rel="prefetch" href="/assets/js/26.5611357c.js"><link rel="prefetch" href="/assets/js/27.c17b5a1d.js"><link rel="prefetch" href="/assets/js/28.d25a87a1.js"><link rel="prefetch" href="/assets/js/29.1490d492.js"><link rel="prefetch" href="/assets/js/30.5c1af3cc.js"><link rel="prefetch" href="/assets/js/31.e51c6f9b.js"><link rel="prefetch" href="/assets/js/33.37d3e9b9.js"><link rel="prefetch" href="/assets/js/34.d0de262a.js"><link rel="prefetch" href="/assets/js/35.5c428da0.js"><link rel="prefetch" href="/assets/js/36.ef928242.js"><link rel="prefetch" href="/assets/js/37.1e663b8b.js"><link rel="prefetch" href="/assets/js/38.f3da67f4.js"><link rel="prefetch" href="/assets/js/39.d844dc3f.js"><link rel="prefetch" href="/assets/js/4.10499883.js"><link rel="prefetch" href="/assets/js/40.ccaf7136.js"><link rel="prefetch" href="/assets/js/41.5a41f0c1.js"><link rel="prefetch" href="/assets/js/42.9a21c370.js"><link rel="prefetch" href="/assets/js/43.f107ee6e.js"><link rel="prefetch" href="/assets/js/44.8afd2798.js"><link rel="prefetch" href="/assets/js/45.174c8c12.js"><link rel="prefetch" href="/assets/js/5.a6acc31c.js"><link rel="prefetch" href="/assets/js/6.56200eb6.js"><link rel="prefetch" href="/assets/js/7.ab8ffd39.js"><link rel="prefetch" href="/assets/js/8.f847aa7a.js"><link rel="prefetch" href="/assets/js/9.cf5a45fa.js">
    <link rel="stylesheet" href="/assets/css/0.styles.41761744.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">What is FE</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/programming-basics/编程模式/函数式编程.html" class="nav-link">
  编程基础
</a></div><div class="nav-item"><a href="/syntax&amp;API/HTML/关于HTML.html" class="nav-link">
  语法和API
</a></div><div class="nav-item"><a href="/network/" class="nav-link">
  网络和通讯
</a></div><div class="nav-item"><a href="/development-process/Git/git命令.html" class="nav-link">
  开发流程
</a></div><div class="nav-item"><a href="/engineering/webpack/webpack基础学习.html" class="nav-link">
  前端工程化
</a></div><div class="nav-item"><a href="/runnnig-monitoring/安全/CSRF.html" class="nav-link">
  运行与监控
</a></div><div class="nav-item"><a href="/framework/React/关于react-hook.html" class="nav-link">
  前端框架
</a></div><div class="nav-item"><a href="/tool&amp;plugin/" class="nav-link">
  常用工具与插件
</a></div><div class="nav-item"><a href="/server/" class="nav-link">
  服务器端
</a></div><div class="nav-item"><a href="/more/" class="nav-link">
  技术广度
</a></div><div class="nav-item"><a href="https://github.com/licop/What_is_FE" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/programming-basics/编程模式/函数式编程.html" class="nav-link">
  编程基础
</a></div><div class="nav-item"><a href="/syntax&amp;API/HTML/关于HTML.html" class="nav-link">
  语法和API
</a></div><div class="nav-item"><a href="/network/" class="nav-link">
  网络和通讯
</a></div><div class="nav-item"><a href="/development-process/Git/git命令.html" class="nav-link">
  开发流程
</a></div><div class="nav-item"><a href="/engineering/webpack/webpack基础学习.html" class="nav-link">
  前端工程化
</a></div><div class="nav-item"><a href="/runnnig-monitoring/安全/CSRF.html" class="nav-link">
  运行与监控
</a></div><div class="nav-item"><a href="/framework/React/关于react-hook.html" class="nav-link">
  前端框架
</a></div><div class="nav-item"><a href="/tool&amp;plugin/" class="nav-link">
  常用工具与插件
</a></div><div class="nav-item"><a href="/server/" class="nav-link">
  服务器端
</a></div><div class="nav-item"><a href="/more/" class="nav-link">
  技术广度
</a></div><div class="nav-item"><a href="https://github.com/licop/What_is_FE" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>HTML</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/syntax&amp;API/HTML/关于HTML.html" class="sidebar-link">关于 HTML</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>CSS</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/syntax&amp;API/CSS/css单位中px和em,rem的区别.html" class="sidebar-link">css 单位中 px 和 em,rem 的区别</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>ES语法</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/syntax&amp;API/ES语法/Javascript异步编程.html" class="sidebar-link">Javascript 异步编程</a></li><li><a href="/syntax&amp;API/ES语法/promise源码实现.html" class="active sidebar-link">promise 源码实现</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/syntax&amp;API/ES语法/promise源码实现.html#promise-类核心逻辑实现" class="sidebar-link">Promise 类核心逻辑实现</a></li><li class="sidebar-sub-header"><a href="/syntax&amp;API/ES语法/promise源码实现.html#加入异步逻辑" class="sidebar-link">加入异步逻辑</a></li><li class="sidebar-sub-header"><a href="/syntax&amp;API/ES语法/promise源码实现.html#then-添加多个处理函数" class="sidebar-link">then 添加多个处理函数</a></li><li class="sidebar-sub-header"><a href="/syntax&amp;API/ES语法/promise源码实现.html#then-方法的链式调用" class="sidebar-link">then 方法的链式调用</a></li><li class="sidebar-sub-header"><a href="/syntax&amp;API/ES语法/promise源码实现.html#捕获错误-then-方法完善" class="sidebar-link">捕获错误 &amp; then 方法完善</a></li><li class="sidebar-sub-header"><a href="/syntax&amp;API/ES语法/promise源码实现.html#添加方法-完善-promise-功能" class="sidebar-link">添加方法，完善 promise 功能</a></li></ul></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>Typescript</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/syntax&amp;API/Typescript/introduction.html" class="sidebar-link">初识 TypeScript</a></li><li><a href="/syntax&amp;API/Typescript/install.html" class="sidebar-link">安装</a></li><li><a href="/syntax&amp;API/Typescript/type.html" class="sidebar-link">基础类型</a></li><li><a href="/syntax&amp;API/Typescript/declare.html" class="sidebar-link">变量声明</a></li><li><a href="/syntax&amp;API/Typescript/interface.html" class="sidebar-link">接口</a></li><li><a href="/syntax&amp;API/Typescript/class.html" class="sidebar-link">类</a></li><li><a href="/syntax&amp;API/Typescript/function.html" class="sidebar-link">函数</a></li><li><a href="/syntax&amp;API/Typescript/generic.html" class="sidebar-link">泛型</a></li><li><a href="/syntax&amp;API/Typescript/inference.html" class="sidebar-link">类型推断</a></li><li><a href="/syntax&amp;API/Typescript/advance.html" class="sidebar-link">高级类型</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="promise-源码实现"><a href="#promise-源码实现" class="header-anchor">#</a> promise 源码实现</h1> <p>用了<code>Promise</code>这么久，应该对<code>Promise</code>使用方法和相关属性很熟悉了，本文将一步一步编写<code>Promise</code>的源码，实现其基本功能。</p> <h2 id="promise-类核心逻辑实现"><a href="#promise-类核心逻辑实现" class="header-anchor">#</a> Promise 类核心逻辑实现</h2> <p>在写代码先看一下 Promise 的一些基础特性：</p> <ul><li><code>Promise</code> 就是一个类 在执行这个类的时候 需要传递一个执行器进去 执行器会立即执行</li> <li><code>Promise</code>中有三种状态 分别为 成功 <code>fulfilled</code> 失败 <code>rejected</code> 等待 <code>pending</code>
其中状态只能从 <code>pending</code> -&gt; <code>fulfilled</code> 或 <code>pending</code> -&gt; <code>rejected</code> 一旦状态确定就不可更改</li> <li><code>resolve</code> 和 <code>reject</code> 函数是用来更改状态的</li> <li><code>then</code> 方法内部做的事情就判断状态 如果状态是成功 调用成功的回调函数 如果状态是失败 调用失败回调函数 then 方法是被定义在原型对象中的</li> <li><code>then</code> 成功回调有一个参数 表示成功之后的值 then 失败回调有一个参数 表示失败后的原因</li> <li>同一个 <code>promise</code> 对象下面的 <code>then</code> 方法是可以被调用多次的</li> <li><code>then</code> 方法是可以被链式调用的, 后面 <code>then</code> 方法的回调函数拿到值的是上一个 <code>then</code> 方法的回调函数的返回值</li></ul> <p>由以上特性实现 <code>Promise</code> 类的核心逻辑, 除了<code>then</code> 方法链式调用功能</p> <div class="language- extra-class"><pre class="language-text"><code>const PENDING = 'pending'; // 等待
const FULFILLED = 'fullilled' // 成功
const REJECTED = 'rejected' // 失败

class MyPromise {
  constructor(executor) {
    executor(this.resolve, this.reject)
  }
  // promise 状态
  status = PENDING;
  // 成功之后的值
  value = undefined;
  // 失败之后的值
  reason = undefined;


  resolve = (value) =&gt; {
    if(this.status !== PENDING) return;
    // 将状态更改为成功
    this.status = FULFILLED;
    // 保存成功之后的值
    this.value = value
  }

  reject = (reason) =&gt; {
    if(this.status !== PENDING) return;
    // 将状态更改为失败
    this.status = REJECTED;
    this.reason = reason;
  }

  then = (successCallback, failCallback) =&gt; {
    // 判断状态
    if(this.status === FULFILLED) {
      successCallback(this.value);
    } else if(this.status === REJECTED) {
      failCallback(this.reason);
    }
  }
}

</code></pre></div><h2 id="加入异步逻辑"><a href="#加入异步逻辑" class="header-anchor">#</a> 加入异步逻辑</h2> <p>可以发现以上代码当<code>executor</code>内包含异步代码是有问题的，<code>then</code>方法开始执行后，<code>resolve</code>方法调用还没改变状态，所以异步函数没有调用。</p> <p><code>then</code> 方法加入异步逻辑,等异步任务执行完在执行回调函数，将回调函数在 <code>pending</code> 状态下存储起来，等待成功或失败之后再调用。</p> <div class="language- extra-class"><pre class="language-text"><code>class MyPromise {
    constructor(executor) {
        executor(this.resolve, this.reject)
    }
    // promise 状态
    status = PENDING;
    // 成功之后的值
    value = undefined;
    // 失败之后的值
    reason = undefined
    // 成功回调
    successCallback = undefined;
    // 失败回调
    failCallback = undefined;

    resolve = (value) =&gt; {
        if(this.status !== PENDING) return;
        // 将状态更改为成功
        this.status = FULFILLED;
        // 保存成功之后的值
        this.value = value
        // 判断成功回调是否存在，如果存在调用
        this.successCallback &amp;&amp; this.successCallback(this.value)
    }

    reject = (reason) =&gt; {
        if(this.status !== PENDING) return;
        // 将状态更改为失败
        this.status = REJECTED;
        this.reason = reason;
        // 判断失败回调是否存在，如果存在调用
        this.failCallback &amp;&amp; this.failCallback(this.value)
    }

    then = (successCallback, failCallback) =&gt; {
        // 判断状态
        if(this.status === FULFILLED) {
            successCallback(this.value);
        } else if(this.status === REJECTED) {
            failCallback(this.reason);
        } else {
            // 等待
            // 将成功回调和失败回调存储起来
            this.successCallback = successCallback;
            this.failCallback = failCallback;
        }
    }
}

</code></pre></div><h2 id="then-添加多个处理函数"><a href="#then-添加多个处理函数" class="header-anchor">#</a> then 添加多个处理函数</h2> <p>目前<code>Promise</code>只支持一个 then 方法。</p> <p>实现 <code>then</code> 添加多个处理函数，将 <code>this.successCallback</code>, <code>this.failCallback</code> 变成数组</p> <div class="language- extra-class"><pre class="language-text"><code>class MyPromise {
    constructor(executor) {
        executor(this.resolve, this.reject)
    }
    // promise 状态
    status = PENDING;
    // 成功之后的值
    value = undefined;
    // 失败之后的值
    reason = undefined
    // 成功回调
    successCallback = [];
    // 失败回调
    failCallback = [];

    resolve = (value) =&gt; {
        if(this.status !== PENDING) return;
        // 将状态更改为成功
        this.status = FULFILLED;
        // 保存成功之后的值
        this.value = value
        // 判断成功回调是否存在，如果存在调用
        while(this.successCallback.length) this.successCallback.shift()(this.value);
    }

    reject = (reason) =&gt; {
        if(this.status !== PENDING) return;
        // 将状态更改为失败
        this.status = REJECTED;
        this.reason = reason;
        // 判断失败回调是否存在，如果存在调用
        while(this.failCallback.length) this.failCallback.shift()(this.reason);

    }

    then = (successCallback, failCallback) =&gt; {
        // 判断状态
        if(this.status === FULFILLED) {
            successCallback(this.value);
        } else if(this.status === REJECTED) {
            failCallback(this.reason);
        } else {
            // 等待
            // 将成功回调和失败回调存储起来
            this.successCallback.push(successCallback);
            this.failCallback.push(failCallback);
        }
    }
}
</code></pre></div><h2 id="then-方法的链式调用"><a href="#then-方法的链式调用" class="header-anchor">#</a> then 方法的链式调用</h2> <p>实现 <code>then</code> 方法的链式调用，并将 <code>then</code> 方法的返回值传递给下一个 <code>then</code> 方法</p> <ul><li>将 <code>then</code>返回一个 promise 对象，判断回调函数返回的是普通值还是 promise 对象</li> <li>当 <code>promise.then</code> 返回和自身相同的 <code>promise</code> 抛出错误</li></ul> <div class="language- extra-class"><pre class="language-text"><code>class MyPromise {
    constructor(executor) {
        executor(this.resolve, this.reject)
    }
    // promise 状态
    status = PENDING;
    // 成功之后的值
    value = undefined;
    // 失败之后的值
    reason = undefined
    // 成功回调
    successCallback = [];
    // 失败回调
    failCallback = [];

    resolve = (value) =&gt; {
        if(this.status !== PENDING) return;
        // 将状态更改为成功
        this.status = FULFILLED;
        // 保存成功之后的值
        this.value = value
        // 判断成功回调是否存在，如果存在调用
        while(this.successCallback.length) this.successCallback.shift()(this.value);
    }

    reject = (reason) =&gt; {
        if(this.status !== PENDING) return;
        // 将状态更改为失败
        this.status = REJECTED;
        this.reason = reason;
        // 判断失败回调是否存在，如果存在调用
        while(this.failCallback.length) this.failCallback.shift()(this.reason);

    }

    then = (successCallback, failCallback) =&gt; {
        let promise2 = new MyPromise((resolve, reject) =&gt; {
            // 判断状态
            if(this.status === FULFILLED) {
                // 变成异步代码，等promise2主流程执行完后再调用，可获取promise2
                setTimeout(() =&gt; {
                    let x = successCallback(this.value);
                    // 判断x的值是普通值还是promise对象
                    // 如果是普通值 直接调用resolve
                    // 如果是promise对象 查看promise对象的返回结果
                    // 再根据promise对象的返回据结果决定调用resolve还是调用reject
                    resolvePromise(promise2, x, resolve, reject)
                }, 0);

            } else if(this.status === REJECTED) {
                failCallback(this.reason);
            } else {
                // 等待
                // 将成功回调和失败回调存储起来
                this.successCallback.push(successCallback);
                this.failCallback.push(failCallback);
            }
        })

        return promise2;
    }
}

function resolvePromise(promise2, x, resolve, reject) {
    // 当promise.then 返回和自身相同promise报错
    if(promise2 === x) {
        return reject(new TypeError('Chaining cycle detected for promise #&lt;Promise&gt;'))
    }
    if(x instanceof MyPromise) {
        x.then(resolve, reject)
    } else {
        // 普通值
        resolve(x)
    }
}
</code></pre></div><h2 id="捕获错误-then-方法完善"><a href="#捕获错误-then-方法完善" class="header-anchor">#</a> 捕获错误 &amp; then 方法完善</h2> <ul><li>在执行器和回调函数添加 try catch 异常捕获，当发成错误是则直接调用 reject</li> <li>将 then 方法的参数变成可选参数
<ul><li>promise.then().then().then(value =&gt; console.log(value)) 最后的<code>then</code>方法的 value 可以接收到 promise 的返回值</li></ul></li></ul> <div class="language- extra-class"><pre class="language-text"><code>class MyPromise {
    constructor(executor) {
        try {
            executor(this.resolve, this.reject)
        } catch(e) {
            this.reject(e)
        }
    }

    // promise 状态
    status = PENDING;
    // 成功之后的值
    value = undefined;
    // 失败之后的值
    reason = undefined
    // 成功回调
    successCallback = [];
    // 失败回调
    failCallback = [];

    resolve = (value) =&gt; {
        if(this.status !== PENDING) return;
        // 将状态更改为成功
        this.status = FULFILLED;
        // 保存成功之后的值
        this.value = value
        // 判断成功回调是否存在，如果存在调用
        while(this.successCallback.length) this.successCallback.shift()();
    }

    reject = (reason) =&gt; {
        if(this.status !== PENDING) return;
        // 将状态更改为失败
        this.status = REJECTED;
        this.reason = reason;
        // 判断失败回调是否存在，如果存在调用
        while(this.failCallback.length) this.failCallback.shift()();

    }

    then = (successCallback, failCallback) =&gt; {
        successCallback = successCallback || (value =&gt; value);
        failCallback = failCallback || (reason =&gt; {throw reason});

        let promise2 = new MyPromise((resolve, reject) =&gt; {
            // 判断状态
            if(this.status === FULFILLED) {
                // 变成异步代码，等promise2主流程执行完后再调用，可获取promise2
                setTimeout(() =&gt; {
                    try {
                        let x = successCallback(this.value);
                        // 判断x的值是普通值还是promise对象
                        // 如果是普通值 直接调用resolve
                        // 如果是promise对象 查看promise对象的返回结果
                        // 再根据promise对象的返回据结果决定调用resolve还是调用reject
                        resolvePromise(promise2, x, resolve, reject)
                    } catch (e) {
                        reject(e)
                    }

                }, 0);

            } else if(this.status === REJECTED) {
                setTimeout(() =&gt; {
                    try {
                        let x = failCallback(this.reason);
                        // 判断x的值是普通值还是promise对象
                        // 如果是普通值 直接调用resolve
                        // 如果是promise对象 查看promise对象的返回结果
                        // 再根据promise对象的返回据结果决定调用resolve还是调用reject
                        resolvePromise(promise2, x, resolve, reject)
                    } catch (e) {
                        reject(e)
                    }

                }, 0);

            } else {
                // 等待
                // 将成功回调和失败回调存储起来
                this.successCallback.push(() =&gt; {
                    setTimeout(() =&gt; {
                        try {
                            let x = successCallback(this.value);
                            // 判断x的值是普通值还是promise对象
                            // 如果是普通值 直接调用resolve
                            // 如果是promise对象 查看promise对象的返回结果
                            // 再根据promise对象的返回据结果决定调用resolve还是调用reject
                            resolvePromise(promise2, x, resolve, reject)
                        } catch (e) {
                            reject(e)
                        }

                    }, 0);
                });
                this.failCallback.push(() =&gt; {
                    setTimeout(() =&gt; {
                        try {
                            let x = failCallback(this.reason);
                            // 判断x的值是普通值还是promise对象
                            // 如果是普通值 直接调用resolve
                            // 如果是promise对象 查看promise对象的返回结果
                            // 再根据promise对象的返回据结果决定调用resolve还是调用reject
                            resolvePromise(promise2, x, resolve, reject)
                        } catch (e) {
                            reject(e)
                        }

                    }, 0);
                });
            }
        })

        return promise2;
    }
}

function resolvePromise(promise2, x, resolve, reject) {
    // 当promise.then 返回和自身相同promise报错
    if(promise2 === x) {
        return reject(new TypeError('Chaining cycle detected for promise #&lt;Promise&gt;'))
    }

    if(x instanceof MyPromise) {
        x.then(resolve, reject)
    } else {
        // 普通值
        resolve(x)
    }
}
</code></pre></div><h2 id="添加方法-完善-promise-功能"><a href="#添加方法-完善-promise-功能" class="header-anchor">#</a> 添加方法，完善 promise 功能</h2> <p>给 MyPromise 类添加<code>all</code>和<code>resolve</code>静态方法，和<code>catch</code>和<code>finally</code>方法，完善 promise 功能，使其更接近真实的 Promise 类，这样我们自己 Promise 类就大功告成了</p> <div class="language- extra-class"><pre class="language-text"><code>const PENDING = 'pending'; // 等待
const FULFILLED = 'fullilled' // 成功
const REJECTED = 'rejected' // 失败

class MyPromise {
    constructor(executor) {
        try {
            executor(this.resolve, this.reject)
        } catch(e) {
            this.reject(e)
        }
    }

    // promise 状态
    status = PENDING;
    // 成功之后的值
    value = undefined;
    // 失败之后的值
    reason = undefined
    // 成功回调
    successCallback = [];
    // 失败回调
    failCallback = [];

    resolve = (value) =&gt; {
        if(this.status !== PENDING) return;
        // 将状态更改为成功
        this.status = FULFILLED;
        // 保存成功之后的值
        this.value = value
        // 判断成功回调是否存在，如果存在调用
        while(this.successCallback.length) this.successCallback.shift()();
    }

    reject = (reason) =&gt; {
        if(this.status !== PENDING) return;
        // 将状态更改为失败
        this.status = REJECTED;
        this.reason = reason;
        // 判断失败回调是否存在，如果存在调用
        while(this.failCallback.length) this.failCallback.shift()();

    }

    then = (successCallback, failCallback) =&gt; {
        successCallback = successCallback || (value =&gt; value);
        failCallback = failCallback || (reason =&gt; {throw reason});

        let promise2 = new MyPromise((resolve, reject) =&gt; {
            // 判断状态
            if(this.status === FULFILLED) {
                // 变成异步代码，等promise2主流程执行完后再调用，可获取promise2
                setTimeout(() =&gt; {
                    try {
                        let x = successCallback(this.value);
                        // 判断x的值是普通值还是promise对象
                        // 如果是普通值 直接调用resolve
                        // 如果是promise对象 查看promise对象的返回结果
                        // 再根据promise对象的返回据结果决定调用resolve还是调用reject
                        resolvePromise(promise2, x, resolve, reject)
                    } catch (e) {
                        reject(e)
                    }

                }, 0);

            } else if(this.status === REJECTED) {
                setTimeout(() =&gt; {
                    try {
                        let x = failCallback(this.reason);
                        // 判断x的值是普通值还是promise对象
                        // 如果是普通值 直接调用resolve
                        // 如果是promise对象 查看promise对象的返回结果
                        // 再根据promise对象的返回据结果决定调用resolve还是调用reject
                        resolvePromise(promise2, x, resolve, reject)
                    } catch (e) {
                        reject(e)
                    }

                }, 0);

            } else {
                // 等待
                // 将成功回调和失败回调存储起来
                this.successCallback.push(() =&gt; {
                    setTimeout(() =&gt; {
                        try {
                            let x = successCallback(this.value);
                            // 判断x的值是普通值还是promise对象
                            // 如果是普通值 直接调用resolve
                            // 如果是promise对象 查看promise对象的返回结果
                            // 再根据promise对象的返回据结果决定调用resolve还是调用reject
                            resolvePromise(promise2, x, resolve, reject)
                        } catch (e) {
                            reject(e)
                        }

                    }, 0);
                });
                this.failCallback.push(() =&gt; {
                    setTimeout(() =&gt; {
                        try {
                            let x = failCallback(this.reason);
                            // 判断x的值是普通值还是promise对象
                            // 如果是普通值 直接调用resolve
                            // 如果是promise对象 查看promise对象的返回结果
                            // 再根据promise对象的返回据结果决定调用resolve还是调用reject
                            resolvePromise(promise2, x, resolve, reject)
                        } catch (e) {
                            reject(e)
                        }

                    }, 0);
                });
            }
        })

        return promise2;
    }
    // 无论结果返回成功还是失败都要调用一次
    finally(callback) {
        // 通过then方法得到当前promise的状态
        return this.then(value =&gt; {
            return MyPromise.resolve(callback()).then(() =&gt; value)
        }, reason =&gt; {
            return MyPromise.resolve(callback()).then(() =&gt; {throw reason})
        })
    }

    catch(failCallback) {
        return this.then(undefined, failCallback)
    }

    static all(array) {
        let result = [];
        let index = 0

        return new MyPromise((resolve, reject) =&gt; {
            function addData(key, value) {
                result[key] = value
                index++
                if(index === array.length) {
                    resolve(result);
                }
            }

            for(let i = 0; i &lt; array.length; i++) {
                let current = array[i];
                if(current instanceof MyPromise) {
                    // promise对象
                    current.then(value =&gt; addData(i, value), reason =&gt; reject(reason))
                } else {
                    // 普通值
                    addData(i, array[i])
                }
            }
        })
    }

    static resolve(value) {
        if(value instanceof MyPromise) return value;
        return new MyPromise(resolve =&gt; resolve(value))
    }
}

function resolvePromise(promise2, x, resolve, reject) {
    // 当promise.then 返回和自身相同promise报错
    if(promise2 === x) {
        return reject(new TypeError('Chaining cycle detected for promise #&lt;Promise&gt;'))
    }
    if(x instanceof MyPromise) {
        x.then(resolve, reject)
    } else {
        // 普通值
        resolve(x)
    }
}

</code></pre></div></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/syntax&amp;API/ES语法/Javascript异步编程.html" class="prev">
        Javascript 异步编程
      </a></span> <span class="next"><a href="/syntax&amp;API/Typescript/introduction.html">
        初识 TypeScript
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"><!----><!----></div></div>
    <script src="/assets/js/app.2a46a431.js" defer></script><script src="/assets/js/2.5e2d37c1.js" defer></script><script src="/assets/js/32.47bddd0e.js" defer></script><script src="/assets/js/3.b304fdc1.js" defer></script>
  </body>
</html>
