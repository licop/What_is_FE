<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>关于 React 和不可变数据 | What is FE</title>
    <meta name="generator" content="VuePress 1.7.1">
    
    <meta name="description" content="构建自己的系统的 Web 前端知识体系">
    
    <link rel="preload" href="/assets/css/0.styles.05e426fd.css" as="style"><link rel="preload" href="/assets/js/app.23d3122b.js" as="script"><link rel="preload" href="/assets/js/2.5e2d37c1.js" as="script"><link rel="preload" href="/assets/js/42.4409db03.js" as="script"><link rel="preload" href="/assets/js/3.b304fdc1.js" as="script"><link rel="prefetch" href="/assets/js/10.a37a353b.js"><link rel="prefetch" href="/assets/js/11.d1b90c3d.js"><link rel="prefetch" href="/assets/js/12.d3bf7b11.js"><link rel="prefetch" href="/assets/js/13.6f6b4894.js"><link rel="prefetch" href="/assets/js/14.2c89a43b.js"><link rel="prefetch" href="/assets/js/15.565302df.js"><link rel="prefetch" href="/assets/js/16.863ec29e.js"><link rel="prefetch" href="/assets/js/17.81c8a830.js"><link rel="prefetch" href="/assets/js/18.4e8004a4.js"><link rel="prefetch" href="/assets/js/19.04ae3cb6.js"><link rel="prefetch" href="/assets/js/20.43106a54.js"><link rel="prefetch" href="/assets/js/21.56a2417a.js"><link rel="prefetch" href="/assets/js/22.d0c70b78.js"><link rel="prefetch" href="/assets/js/23.9da4a7d3.js"><link rel="prefetch" href="/assets/js/24.6382844b.js"><link rel="prefetch" href="/assets/js/25.33b58a3b.js"><link rel="prefetch" href="/assets/js/26.f5dfaeb5.js"><link rel="prefetch" href="/assets/js/27.a01f0f1c.js"><link rel="prefetch" href="/assets/js/28.8f4ee848.js"><link rel="prefetch" href="/assets/js/29.14745b03.js"><link rel="prefetch" href="/assets/js/30.339e63b1.js"><link rel="prefetch" href="/assets/js/31.299a0ec5.js"><link rel="prefetch" href="/assets/js/32.36a9b7fc.js"><link rel="prefetch" href="/assets/js/33.02f2ea3b.js"><link rel="prefetch" href="/assets/js/34.8c2fd8ae.js"><link rel="prefetch" href="/assets/js/35.e1131b1f.js"><link rel="prefetch" href="/assets/js/36.ca800f3d.js"><link rel="prefetch" href="/assets/js/37.834c20f9.js"><link rel="prefetch" href="/assets/js/38.f0c65a45.js"><link rel="prefetch" href="/assets/js/39.4d09d993.js"><link rel="prefetch" href="/assets/js/4.61dc0fce.js"><link rel="prefetch" href="/assets/js/40.f50d8b03.js"><link rel="prefetch" href="/assets/js/41.e634a1d4.js"><link rel="prefetch" href="/assets/js/43.eb927c4f.js"><link rel="prefetch" href="/assets/js/44.c2c8ac29.js"><link rel="prefetch" href="/assets/js/45.8c89abb2.js"><link rel="prefetch" href="/assets/js/46.1f598736.js"><link rel="prefetch" href="/assets/js/47.0dc0c336.js"><link rel="prefetch" href="/assets/js/48.7311c091.js"><link rel="prefetch" href="/assets/js/49.0590a5ee.js"><link rel="prefetch" href="/assets/js/5.a6acc31c.js"><link rel="prefetch" href="/assets/js/50.5e6aa420.js"><link rel="prefetch" href="/assets/js/51.daaa3ea1.js"><link rel="prefetch" href="/assets/js/52.3be16e9a.js"><link rel="prefetch" href="/assets/js/53.f73c6710.js"><link rel="prefetch" href="/assets/js/54.a7d47983.js"><link rel="prefetch" href="/assets/js/55.5de6d42b.js"><link rel="prefetch" href="/assets/js/56.23b3eed4.js"><link rel="prefetch" href="/assets/js/57.a3fcd7a7.js"><link rel="prefetch" href="/assets/js/58.bceb7f62.js"><link rel="prefetch" href="/assets/js/59.1755e44b.js"><link rel="prefetch" href="/assets/js/6.56200eb6.js"><link rel="prefetch" href="/assets/js/60.0bd98a77.js"><link rel="prefetch" href="/assets/js/61.f0cd536c.js"><link rel="prefetch" href="/assets/js/62.1d73b33b.js"><link rel="prefetch" href="/assets/js/63.e2f2897f.js"><link rel="prefetch" href="/assets/js/64.8f52af13.js"><link rel="prefetch" href="/assets/js/65.d3483f2c.js"><link rel="prefetch" href="/assets/js/66.142ba4e5.js"><link rel="prefetch" href="/assets/js/67.a5d671a7.js"><link rel="prefetch" href="/assets/js/68.f6e3aa17.js"><link rel="prefetch" href="/assets/js/69.fdf1350c.js"><link rel="prefetch" href="/assets/js/7.ab8ffd39.js"><link rel="prefetch" href="/assets/js/70.9dff3efb.js"><link rel="prefetch" href="/assets/js/71.262665e8.js"><link rel="prefetch" href="/assets/js/72.73136398.js"><link rel="prefetch" href="/assets/js/73.e20e1cda.js"><link rel="prefetch" href="/assets/js/74.2de2dab9.js"><link rel="prefetch" href="/assets/js/75.d033acb2.js"><link rel="prefetch" href="/assets/js/76.5f13e879.js"><link rel="prefetch" href="/assets/js/77.6652698b.js"><link rel="prefetch" href="/assets/js/78.afe723ed.js"><link rel="prefetch" href="/assets/js/79.3bb9a95d.js"><link rel="prefetch" href="/assets/js/8.f847aa7a.js"><link rel="prefetch" href="/assets/js/80.84bf0a56.js"><link rel="prefetch" href="/assets/js/81.88c56010.js"><link rel="prefetch" href="/assets/js/82.2b75bb62.js"><link rel="prefetch" href="/assets/js/83.3230acf5.js"><link rel="prefetch" href="/assets/js/84.02f48b8c.js"><link rel="prefetch" href="/assets/js/85.05feeacd.js"><link rel="prefetch" href="/assets/js/86.5abf208e.js"><link rel="prefetch" href="/assets/js/87.cec0c2e6.js"><link rel="prefetch" href="/assets/js/88.e62b7e95.js"><link rel="prefetch" href="/assets/js/89.708bba5c.js"><link rel="prefetch" href="/assets/js/9.93fa1ba1.js"><link rel="prefetch" href="/assets/js/90.f79f6a80.js"><link rel="prefetch" href="/assets/js/91.98970e22.js"><link rel="prefetch" href="/assets/js/92.de5dd0bd.js"><link rel="prefetch" href="/assets/js/93.1b91999e.js"><link rel="prefetch" href="/assets/js/94.7d7076a6.js"><link rel="prefetch" href="/assets/js/95.b2b0edd4.js">
    <link rel="stylesheet" href="/assets/css/0.styles.05e426fd.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">What is FE</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/programming-basics/编程模式/函数式编程.html" class="nav-link">
  编程基础
</a></div><div class="nav-item"><a href="/syntax&amp;API/HTML/关于HTML.html" class="nav-link">
  语法和API
</a></div><div class="nav-item"><a href="/network/" class="nav-link">
  网络和通讯
</a></div><div class="nav-item"><a href="/development-process/Git/git命令.html" class="nav-link">
  开发流程
</a></div><div class="nav-item"><a href="/engineering/webpack/webpack基础学习.html" class="nav-link">
  前端工程化
</a></div><div class="nav-item"><a href="/runnnig-monitoring/安全/CSRF.html" class="nav-link">
  运行与监控
</a></div><div class="nav-item"><a href="/framework/React/React基础学习.html" class="nav-link">
  前端框架
</a></div><div class="nav-item"><a href="/tool&amp;method/常用方法代码总结/封装fetch方法.html" class="nav-link">
  常用工具与方法
</a></div><div class="nav-item"><a href="/server/nodejs/Nodejs学习笔记.html" class="nav-link">
  服务器端
</a></div><div class="nav-item"><a href="/more/" class="nav-link">
  技术广度
</a></div><div class="nav-item"><a href="https://github.com/licop/What_is_FE" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/programming-basics/编程模式/函数式编程.html" class="nav-link">
  编程基础
</a></div><div class="nav-item"><a href="/syntax&amp;API/HTML/关于HTML.html" class="nav-link">
  语法和API
</a></div><div class="nav-item"><a href="/network/" class="nav-link">
  网络和通讯
</a></div><div class="nav-item"><a href="/development-process/Git/git命令.html" class="nav-link">
  开发流程
</a></div><div class="nav-item"><a href="/engineering/webpack/webpack基础学习.html" class="nav-link">
  前端工程化
</a></div><div class="nav-item"><a href="/runnnig-monitoring/安全/CSRF.html" class="nav-link">
  运行与监控
</a></div><div class="nav-item"><a href="/framework/React/React基础学习.html" class="nav-link">
  前端框架
</a></div><div class="nav-item"><a href="/tool&amp;method/常用方法代码总结/封装fetch方法.html" class="nav-link">
  常用工具与方法
</a></div><div class="nav-item"><a href="/server/nodejs/Nodejs学习笔记.html" class="nav-link">
  服务器端
</a></div><div class="nav-item"><a href="/more/" class="nav-link">
  技术广度
</a></div><div class="nav-item"><a href="https://github.com/licop/What_is_FE" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>React</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/framework/React/React基础学习.html" class="sidebar-link">React 基础学习</a></li><li><a href="/framework/React/关于React-Hooks.html" class="sidebar-link">关于 React-Hooks</a></li><li><a href="/framework/React/编写React应用程序步骤.html" class="sidebar-link">编写 React 应用程序步骤</a></li><li><a href="/framework/React/关于虚拟Dom和Diff算法.html" class="sidebar-link">Virtual DOM 及 Diff 算法</a></li><li><a href="/framework/React/关于React和不可变数据.html" class="active sidebar-link">关于 React 和不可变数据</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/framework/React/关于React和不可变数据.html#什么是不可变数据" class="sidebar-link">什么是不可变数据</a></li><li class="sidebar-sub-header"><a href="/framework/React/关于React和不可变数据.html#react-为什么需要不可变数据" class="sidebar-link">React 为什么需要不可变数据</a></li><li class="sidebar-sub-header"><a href="/framework/React/关于React和不可变数据.html#更多参考" class="sidebar-link">更多参考</a></li></ul></li><li><a href="/framework/React/Fiber的作用和原理.html" class="sidebar-link">Fiber 的作用和原理</a></li><li><a href="/framework/React/应用状态该用React组件状态还是Redux.html" class="sidebar-link">应用状态该用 React 组件状态还是 Redux</a></li><li><a href="/framework/React/自定义Hooks和高阶组件.html" class="sidebar-link">自定义 Hooks 和高阶组件</a></li><li><a href="/framework/React/React项目的文件目录结构.html" class="sidebar-link">React 项目的文件目录结构</a></li><li><a href="/framework/React/React组件性能优化.html" class="sidebar-link">React 组件性能优化</a></li><li><a href="/framework/React/关于Redux.html" class="sidebar-link">关于 Redux</a></li><li><a href="/framework/React/Redux源码实现.html" class="sidebar-link">Redux 源码实现</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>Vue</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/framework/Vue/vue-router实现原理.html" class="sidebar-link">vue-router 实现原理</a></li><li><a href="/framework/Vue/vue数据响应式原理.html" class="sidebar-link">vue 数据响应式原理</a></li><li><a href="/framework/Vue/Virtual DOM 介绍以及 Snabbdom 源码解析.html" class="sidebar-link">Virtual DOM 介绍以及 Snabbdom 源码解析</a></li><li><a href="/framework/Vue/Vue 源码解析--Vue 初始化和首次渲染.html" class="sidebar-link">Vue 源码解析--Vue 初始化和首次渲染</a></li><li><a href="/framework/Vue/Vue 源码解析--数据响应式原理.html" class="sidebar-link">Vue 源码解析--数据响应式原理</a></li><li><a href="/framework/Vue/Vue 源码解析--虚拟 Dom.html" class="sidebar-link">Vue 源码解析--虚拟 Dom</a></li><li><a href="/framework/Vue/Vue 源码解析--模板编译.html" class="sidebar-link">Vue 源码解析--模板编译和组件化</a></li><li><a href="/framework/Vue/Vue 源码解析--一些工具方法.html" class="sidebar-link">Vue 源码解析--一些工具方法</a></li><li><a href="/framework/Vue/Vuex 介绍及源码解析.html" class="sidebar-link">Vuex 介绍及源码解析</a></li><li><a href="/framework/Vue/Vue3 的优化.html" class="sidebar-link">Vue3 的优化</a></li><li><a href="/framework/Vue/使用 vue-server-renderer 开发一个 Vue 服务端渲染项目.html" class="sidebar-link">使用 vue-server-renderer 开发一个 Vue 服务端渲染项目</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="关于-react-和不可变数据"><a href="#关于-react-和不可变数据" class="header-anchor">#</a> 关于 React 和不可变数据</h1> <h2 id="什么是不可变数据"><a href="#什么是不可变数据" class="header-anchor">#</a> 什么是不可变数据</h2> <p><strong>不可变数据(Immutable Data)在创建以后，就不可以再被改变。</strong> 这种数据在编程和调试时更容易预测，有利于降低复杂性。同时在 Web 领域，类似监听数据变化这样的功能非常有用，但运行起来可能会比较重，而不可变数据可以简化实现，降低成本。</p> <p>JS 里有没有不可变数据？有。所有原始数据类型（Primitive Types）都是不可变数据类型，包括：undefined、null、boolean、number、BigInt、string、Symbol。但对引用类型，如 Object、Function、Array、Map、Set、Date 等，就不是不可变类型了。</p> <p>object 一般是可变数据，原因是 javascript 的对象使用了引用赋值，新的对象简单的引用了原始对象，改变新的对象将影响到原始对象，例如</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> student1 <span class="token operator">=</span> <span class="token punctuation">{</span>
  school<span class="token operator">:</span> <span class="token string">&quot;Baidu&quot;</span><span class="token punctuation">,</span>
  name<span class="token operator">:</span> <span class="token string">&quot;licop&quot;</span><span class="token punctuation">,</span>
  age<span class="token operator">:</span> <span class="token string">&quot;27&quot;</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">const</span> <span class="token function-variable function">changeStudent</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">student<span class="token punctuation">,</span> newName<span class="token punctuation">,</span> newAge</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> newStudent <span class="token operator">=</span> student<span class="token punctuation">;</span>
  newStudent<span class="token punctuation">.</span>name <span class="token operator">=</span> newName<span class="token punctuation">;</span>
  newStudent<span class="token punctuation">.</span>age <span class="token operator">=</span> newAge<span class="token punctuation">;</span>
  <span class="token keyword">return</span> newStudent<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">const</span> student2 <span class="token operator">=</span> <span class="token function">changeStudent</span><span class="token punctuation">(</span>student1<span class="token punctuation">,</span> <span class="token string">&quot;licop2&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;28&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>student1<span class="token punctuation">,</span> student2<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// Object {school: &quot;Baidu&quot;, name: &quot;licop2&quot;, age: &quot;28&quot;}</span>
<span class="token comment">// Object {school: &quot;Baidu&quot;, name: &quot;licop2&quot;, age: &quot;28&quot;}</span>
</code></pre></div><p>尽管创建了一个新的对象 student2，但是老的对象 student1 也被改动了。这是因为 JS 对象中的赋值是“引用赋值”，即在赋值过程中，传递的是在内存中的引用(memory reference)。具体说就是“栈存储”和“堆存储”的问题。</p> <p>我们可以使用 ES6 中<strong>解构(destructuring)赋值</strong>， 达到我们想要的效果，根据参数，产生一个新对象，并正确赋值，最重要的就是并没有改变原对象。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> student1 <span class="token operator">=</span> <span class="token punctuation">{</span>
  school<span class="token operator">:</span> <span class="token string">&quot;Baidu&quot;</span><span class="token punctuation">,</span>
  name<span class="token operator">:</span> <span class="token string">&quot;licop&quot;</span><span class="token punctuation">,</span>
  age<span class="token operator">:</span> <span class="token string">&quot;27&quot;</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">const</span> <span class="token function-variable function">changeStudent</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">student<span class="token punctuation">,</span> newName<span class="token punctuation">,</span> newAge</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token punctuation">{</span>
    <span class="token operator">...</span>student<span class="token punctuation">,</span> <span class="token comment">//使用解构</span>
    name<span class="token operator">:</span> newName<span class="token punctuation">,</span> <span class="token comment">// 覆盖name属性</span>
    age<span class="token operator">:</span> newAge<span class="token punctuation">,</span> <span class="token comment">// 覆盖age属性</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">const</span> student2 <span class="token operator">=</span> <span class="token function">changeStudent</span><span class="token punctuation">(</span>student1<span class="token punctuation">,</span> <span class="token string">&quot;licop2&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;28&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>student1<span class="token punctuation">,</span> student2<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// Object {school: &quot;Baidu&quot;, name: &quot;licop2&quot;, age: &quot;28&quot;}</span>
<span class="token comment">// Object {school: &quot;Baidu&quot;, name: &quot;licop2&quot;, age: &quot;28&quot;}</span>
</code></pre></div><h2 id="react-为什么需要不可变数据"><a href="#react-为什么需要不可变数据" class="header-anchor">#</a> React 为什么需要不可变数据</h2> <p>这主要还是因为 React 是声明式的框架，为了更新用户看到的页面，我们需要让开发出来的 React 组件响应数据流的变化。这就是说无论开发者，还是 React 框架本身都关注 props、state、context 的数据是否有变化。<strong>对 React 框架，不可变数据可以简化比对数据的实现，降低成本；对开发者，不可变数据在开发和调试过程中更容易被预测。</strong></p> <p><strong>同时在开发 Redux 时也 期望所有状态更新都是使用不可变的方式。</strong></p> <p>接下来看一下 React 在哪些环节会检查数据的变化。</p> <h3 id="协调过程中的数据对比"><a href="#协调过程中的数据对比" class="header-anchor">#</a> 协调过程中的数据对比</h3> <p>首先是最核心的 Fiber 协调引擎，常提到的 Diffing 对比算法就在引擎里，这些对比绝大部分都是在渲染阶段发生的。</p> <p>React 是用 <code>Object.is()</code> 方法来判断两个值是否相等的。在以下过程中，React 会调用 <code>is(oldValue, newValue)</code> 来对比新旧值：</p> <ul><li>更新 state 时，只有新旧 state 值不相等，才把 Fiber 标记为收到更新；</li> <li>更新 Context.Provider 中的 value 值；</li> <li>检查 useEffect、useMemo、useCallback 的依赖值数组，只有每个值的新老值都检查过，其中有不同时，才执行它们的回调；</li> <li>useSyncExternalStore 中检查来自外部的应用状态（比如 Redux）是否有变化，才把 Fiber 标记为收到更新。</li></ul> <p>还有一种情况是对新旧两个对象做<strong>浅对比（Shallow Compare）</strong>，具体实现方式依然是基于 Object.is()。当两个对象属性数量相同，且其中一个对象的每个属性都与另一个对象的同名属性相等时，这两个对象才算相等。在下面的过程中，React 会调用 shallowEqual(oldObj, newObj) 来对比新旧对象（主要是 props）：</p> <ul><li>React.memo 进入更新阶段，如果属性均相同，则跳过该组件继续执行下一个工作；</li> <li>PureComponent 进入更新阶段，如果属性均相同，则跳过该组件继续执行下一个工作。</li></ul> <h3 id="合成事件中的数据对比"><a href="#合成事件中的数据对比" class="header-anchor">#</a> 合成事件中的数据对比</h3> <p>除了协调引擎，还有一处数据对比发生在合成事件中：在触发 onSelect 合成事件前，React 用浅对比判断选中项是否真的有变化，真有变化才会触发事件，否则不会触发。</p> <h3 id="react-memo"><a href="#react-memo" class="header-anchor">#</a> React.Memo</h3> <p><a href="https://zh-hans.reactjs.org/docs/react-api.html#reactmemo" target="_blank" rel="noopener noreferrer">React.Memo<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>为高阶组件。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> MyComponent <span class="token operator">=</span> React<span class="token punctuation">.</span><span class="token function">memo</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token function">MyComponent</span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">/* 使用 props 渲染 */</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">const</span> MyComponent <span class="token operator">=</span> React<span class="token punctuation">.</span><span class="token function">memo</span><span class="token punctuation">(</span>MyComponent<span class="token punctuation">,</span> compare<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 自定义对比函数</span>
</code></pre></div><p>如果你的组件在相同 props 的情况下渲染相同的结果，那么你可以通过将其包装在 <code>React.memo</code> 中调用，以此通过记忆组件渲染结果的方式来提高组件的性能表现。这意味着在这种情况下，React 将跳过渲染组件的操作并直接复用最近一次渲染的结果。</p> <p>React.memo 仅检查 props 变更。如果函数组件被 <code>React.memo</code> 包裹，且其实现中拥有 useState，useReducer 或 useContext 的 Hook，当 state 或 context 发生变化时，它仍会重新渲染。</p> <p>当你不满足于浅对比时，你还可以给这个 API 传入第二个可选参数，一个 compare 函数，compare 函数被调用时会接受 oldProps 和 newProps 两个参数，如果返回 true，则视为相等，反之则视为不等。</p> <h3 id="不可变数据的实现"><a href="#不可变数据的实现" class="header-anchor">#</a> 不可变数据的实现</h3> <p>刚才提到 JS 中的引用类型并不是不可变的。那如果想用它们，该怎么为它们加入不可变特性呢？</p> <h3 id="手工实现"><a href="#手工实现" class="header-anchor">#</a> 手工实现</h3> <p>要领就是<strong>别. 改. 原. 对. 象</strong>。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 数组</span>
<span class="token comment">// 我们可以使用：.map, .filter或者.reduce去达成目标。这些APIs的共同特点就是不会改变原数组，而是产生并返回一个新数组</span>
<span class="token keyword">const</span> itemAdded <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">...</span>oldArray<span class="token punctuation">,</span> newItem<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> itemRemoved <span class="token operator">=</span> oldArray<span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">item</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> item <span class="token operator">!==</span> newItem<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 创建 arr 的备份，并把 c 拼接到最后。</span>
<span class="token keyword">const</span> arr1 <span class="token operator">=</span> arr<span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span><span class="token string">&quot;c&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 可以对原来的数组创建复制体</span>
<span class="token keyword">const</span> arr2 <span class="token operator">=</span> arr<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 对象</span>
<span class="token keyword">const</span> newObj <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token operator">...</span>oldObj<span class="token punctuation">,</span> b<span class="token operator">:</span> <span class="token string">&quot;newValue&quot;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> newObj <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">assign</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span> oldObj<span class="token punctuation">,</span> <span class="token punctuation">{</span> b<span class="token operator">:</span> <span class="token string">&quot;newValue&quot;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>一些经典 APIs 都是 shallow 处理，比如上文提到的 <code>Object.assign</code> 就是典型的浅拷贝。如果遇到嵌套很深的结构，我们就需要手动递归。这样做呢，又会存在性能上的问题。</p> <p>所以有时候我们要借助一些不可变数据的类库来帮助我们处理。</p> <h3 id="可持久化数据结构和-immutable-js"><a href="#可持久化数据结构和-immutable-js" class="header-anchor">#</a> 可持久化数据结构和 Immutable.js</h3> <p>在计算机编程中，**可持久化数据结构（Persistent data structure）**是一种能够在修改之后其保留历史版本（即可以在保留原来数据的基础上进行修改——比如增添、删除、赋值）的数据结构。这种数据结构实际上是不可变对象，因为相关操作不会直接修改被保存的数据，而是会在原版本上产生一个新分支。</p> <p>在 JS 中，可持久化数据结构的代表性实现，就是 FB 开源的<a href="https://immutable-js.com/" target="_blank" rel="noopener noreferrer">immutable.js<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>。这个库提供了 List、Stack、Map、OrderedMap、Set、OrderedSet 和 Record 这些不可变数据类型。用这些类型 API 创建的数据，就是基于可持久化数据结构的不可变数据，可以直接用在 React 中。</p> <p>这里贴两段官方样例代码。首先是神似 JS Array 的 List，你可以看到对 List 对象每个操作都会创建新的 List：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> <span class="token punctuation">{</span> List <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">&quot;immutable&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> list1 <span class="token operator">=</span> <span class="token function">List</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> list2 <span class="token operator">=</span> list1<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> list3 <span class="token operator">=</span> list2<span class="token punctuation">.</span><span class="token function">unshift</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> list4 <span class="token operator">=</span> list1<span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span>list2<span class="token punctuation">,</span> list3<span class="token punctuation">)</span><span class="token punctuation">;</span>
assert<span class="token punctuation">.</span><span class="token function">equal</span><span class="token punctuation">(</span>list1<span class="token punctuation">.</span>size<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
assert<span class="token punctuation">.</span><span class="token function">equal</span><span class="token punctuation">(</span>list2<span class="token punctuation">.</span>size<span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
assert<span class="token punctuation">.</span><span class="token function">equal</span><span class="token punctuation">(</span>list3<span class="token punctuation">.</span>size<span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
assert<span class="token punctuation">.</span><span class="token function">equal</span><span class="token punctuation">(</span>list4<span class="token punctuation">.</span>size<span class="token punctuation">,</span> <span class="token number">13</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
assert<span class="token punctuation">.</span><span class="token function">equal</span><span class="token punctuation">(</span>list4<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>还有这个库的强项嵌套结构，在对象树深处的更新也会返回新的不可变对象：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> <span class="token punctuation">{</span> fromJS <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">&quot;immutable&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> nested <span class="token operator">=</span> <span class="token function">fromJS</span><span class="token punctuation">(</span><span class="token punctuation">{</span> a<span class="token operator">:</span> <span class="token punctuation">{</span> b<span class="token operator">:</span> <span class="token punctuation">{</span> c<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span> <span class="token punctuation">}</span> <span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">const</span> nested2 <span class="token operator">=</span> nested<span class="token punctuation">.</span><span class="token function">mergeDeep</span><span class="token punctuation">(</span><span class="token punctuation">{</span> a<span class="token operator">:</span> <span class="token punctuation">{</span> b<span class="token operator">:</span> <span class="token punctuation">{</span> d<span class="token operator">:</span> <span class="token number">6</span> <span class="token punctuation">}</span> <span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// Map { a: Map { b: Map { c: List [ 3, 4, 5 ], d: 6 } } }</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>nested2<span class="token punctuation">.</span><span class="token function">getIn</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">&quot;a&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;b&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;d&quot;</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 6</span>

<span class="token keyword">const</span> nested3 <span class="token operator">=</span> nested2<span class="token punctuation">.</span><span class="token function">updateIn</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">&quot;a&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;b&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;d&quot;</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter">value</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> value <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>nested3<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// Map { a: Map { b: Map { c: List [ 3, 4, 5 ], d: 7 } } }</span>

<span class="token keyword">const</span> nested4 <span class="token operator">=</span> nested3<span class="token punctuation">.</span><span class="token function">updateIn</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">&quot;a&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;b&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;c&quot;</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter">list</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> list<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// Map { a: Map { b: Map { c: List [ 3, 4, 5, 6 ], d: 7 } } }</span>
</code></pre></div><p><code>Immutable.js</code> 很强大，在 React 技术社区也受到过追捧。然而，不知道你平时是怎么使用的，我反正在 React 项目中使用这个框架时，总是要时刻提醒自己，什么时候可以使用 JS 原生的数据类型，什么时候就必须切换到不可变数据类型，这增加了我在开发过程中的认知负荷。</p> <blockquote><p>在认知心理学中，认知负荷（Cognitive Load）是指工作记忆资源的使用量。</p></blockquote> <p>这虽然会提高程序运行效率，但同时也会降低开发者的开发效率。那么有没有一种方式，既可以沿用熟悉的 JS 数据类型和方法，又可以优雅地加入不可变性？有的，<a href="https://immerjs.github.io/immer/zh-CN/" target="_blank" rel="noopener noreferrer">Immer<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>就是这样一款框架，它可以让 JS 开发者使用原生的 JS 数据结构，和本来不具有不可变性的 JS API，创建和操作不可变数据。</p> <p>以下是来自 <code>Immer</code> 官网的一段样例代码，它的 produce API 接受原数据和数据变更回调函数两个参数，在回调函数中发生的变更，并不会修改原数据本身，而是会返回一个等同于变更结果的新数据：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">import</span> produce <span class="token keyword">from</span> <span class="token string">&quot;immer&quot;</span><span class="token punctuation">;</span>

<span class="token keyword">const</span> nextState <span class="token operator">=</span> <span class="token function">produce</span><span class="token punctuation">(</span>baseState<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter">draft</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  draft<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>done <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
  draft<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">{</span> title<span class="token operator">:</span> <span class="token string">&quot;Tweet about it&quot;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h3 id="在-react-中使用"><a href="#在-react-中使用" class="header-anchor">#</a> 在 React 中使用</h3> <p><code>Immer</code>在函数组件中，可以直接使用 <code>Immer</code> 提供的 Hooks 来替代 useState。</p> <p>安装 Immer</p> <div class="language-js extra-class"><pre class="language-js"><code>npm install immer use<span class="token operator">-</span>immer
</code></pre></div><p>在组件中使用 Immer：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">import</span> React <span class="token keyword">from</span> <span class="token string">&quot;react&quot;</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span> useImmer <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&quot;use-immer&quot;</span><span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token function">App</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span>showAdd<span class="token punctuation">,</span> setShowAdd<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span>todoList<span class="token punctuation">,</span> setTodoList<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useImmer</span><span class="token punctuation">(</span><span class="token punctuation">[</span>
    <span class="token punctuation">{</span> title<span class="token operator">:</span> <span class="token string">'开发任务-1'</span><span class="token punctuation">,</span> status<span class="token operator">:</span> <span class="token string">'22-05-22 18:15'</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token punctuation">{</span> title<span class="token operator">:</span> <span class="token string">'开发任务-3'</span><span class="token punctuation">,</span> status<span class="token operator">:</span> <span class="token string">'22-05-22 18:15'</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token punctuation">{</span> title<span class="token operator">:</span> <span class="token string">'开发任务-5'</span><span class="token punctuation">,</span> status<span class="token operator">:</span> <span class="token string">'22-05-22 18:15'</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token punctuation">{</span> title<span class="token operator">:</span> <span class="token string">'测试任务-3'</span><span class="token punctuation">,</span> status<span class="token operator">:</span> <span class="token string">'22-05-22 18:15'</span> <span class="token punctuation">}</span>
  <span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// ...</span>
  <span class="token keyword">const</span> <span class="token function-variable function">handleSubmit</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">title</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token function">setTodoList</span><span class="token punctuation">(</span><span class="token parameter">draft</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      draft<span class="token punctuation">.</span><span class="token function">unshift</span><span class="token punctuation">(</span><span class="token punctuation">{</span> title<span class="token punctuation">,</span> status<span class="token operator">:</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toDateString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token comment">// ...</span>
</code></pre></div><h3 id="使用-redux-toolkit"><a href="#使用-redux-toolkit" class="header-anchor">#</a> 使用 Redux Toolkit</h3> <p>如果我们应用中使用了 Redux，手动编写不可变的更新逻辑确实繁琐，而且在 reducer 中意外改变状态是 Redux 用户最常犯的一个错误。
推荐使用<strong>Redux Toolkit</strong>工具包。 Redux Toolkit 的 <code>createSlice</code> 函数可以让你以更简单的方式编写不可变更新！</p> <p>createSlice 内部使用 Immer 库。 Immer 使用一种称为 “Proxy” 的特殊 JS 工具来包装你提供的数据，当你尝试 ”mutate“ 这些数据的时候，奇迹发生了，<strong>Immer 会跟踪你尝试进行的所有更改，然后使用该更改列表返回一个安全的、不可变的更新值</strong>，就好像你手动编写了所有不可变的更新逻辑一样。</p> <p>所以下面的代码：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">handwrittenReducer</span><span class="token punctuation">(</span><span class="token parameter">state<span class="token punctuation">,</span> action</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token punctuation">{</span>
    <span class="token operator">...</span>state<span class="token punctuation">,</span>
    first<span class="token operator">:</span> <span class="token punctuation">{</span>
      <span class="token operator">...</span>state<span class="token punctuation">.</span>first<span class="token punctuation">,</span>
      second<span class="token operator">:</span> <span class="token punctuation">{</span>
        <span class="token operator">...</span>state<span class="token punctuation">.</span>first<span class="token punctuation">.</span>second<span class="token punctuation">,</span>
        <span class="token punctuation">[</span>action<span class="token punctuation">.</span>someId<span class="token punctuation">]</span><span class="token operator">:</span> <span class="token punctuation">{</span>
          <span class="token operator">...</span>state<span class="token punctuation">.</span>first<span class="token punctuation">.</span>second<span class="token punctuation">[</span>action<span class="token punctuation">.</span>someId<span class="token punctuation">]</span><span class="token punctuation">,</span>
          fourth<span class="token operator">:</span> action<span class="token punctuation">.</span>someValue<span class="token punctuation">,</span>
        <span class="token punctuation">}</span><span class="token punctuation">,</span>
      <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>可以变成这样：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">reducerWithImmer</span><span class="token punctuation">(</span><span class="token parameter">state<span class="token punctuation">,</span> action</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  state<span class="token punctuation">.</span>first<span class="token punctuation">.</span>second<span class="token punctuation">[</span>action<span class="token punctuation">.</span>someId<span class="token punctuation">]</span><span class="token punctuation">.</span>fourth <span class="token operator">=</span> action<span class="token punctuation">.</span>someValue<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><blockquote><p>你只能在 Redux Toolkit 的 createSlice 和 createReducer 中编写 “mutation” 逻辑，因为它们在内部使用 Immer！如果你在没有 Immer 的 reducer 中编写 mutation 逻辑，它将改变状态并导致错误！</p></blockquote> <h2 id="更多参考"><a href="#更多参考" class="header-anchor">#</a> 更多参考</h2> <ul><li><a href="https://juejin.cn/post/6844903470718255118" target="_blank" rel="noopener noreferrer">谈一谈前端“不可变数据”和函数式编程<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="https://cn.redux.js.org/tutorials/essentials/part-2-app-structure/" target="_blank" rel="noopener noreferrer">Redux 官方文档关于不可变数据<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/framework/React/关于虚拟Dom和Diff算法.html" class="prev">
        Virtual DOM 及 Diff 算法
      </a></span> <span class="next"><a href="/framework/React/Fiber的作用和原理.html">
        Fiber 的作用和原理
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"><!----><!----></div></div>
    <script src="/assets/js/app.23d3122b.js" defer></script><script src="/assets/js/2.5e2d37c1.js" defer></script><script src="/assets/js/42.4409db03.js" defer></script><script src="/assets/js/3.b304fdc1.js" defer></script>
  </body>
</html>
