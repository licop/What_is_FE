<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>vue 数据响应式原理 | What is FE</title>
    <meta name="generator" content="VuePress 1.7.1">
    
    <meta name="description" content="构建自己的系统的 Web 前端知识体系">
    
    <link rel="preload" href="/assets/css/0.styles.41761744.css" as="style"><link rel="preload" href="/assets/js/app.95b0f20d.js" as="script"><link rel="preload" href="/assets/js/2.5e2d37c1.js" as="script"><link rel="preload" href="/assets/js/35.1a00cbbe.js" as="script"><link rel="preload" href="/assets/js/3.b304fdc1.js" as="script"><link rel="prefetch" href="/assets/js/10.a1bb7c5b.js"><link rel="prefetch" href="/assets/js/11.460b07fa.js"><link rel="prefetch" href="/assets/js/12.5b161d54.js"><link rel="prefetch" href="/assets/js/13.a983f7f5.js"><link rel="prefetch" href="/assets/js/14.6bac40a6.js"><link rel="prefetch" href="/assets/js/15.61d3cd46.js"><link rel="prefetch" href="/assets/js/16.568edfc0.js"><link rel="prefetch" href="/assets/js/17.9dae5907.js"><link rel="prefetch" href="/assets/js/18.fc9029a4.js"><link rel="prefetch" href="/assets/js/19.0bc0bc9c.js"><link rel="prefetch" href="/assets/js/20.79157225.js"><link rel="prefetch" href="/assets/js/21.cc5d852a.js"><link rel="prefetch" href="/assets/js/22.8fe0ab17.js"><link rel="prefetch" href="/assets/js/23.3d00d487.js"><link rel="prefetch" href="/assets/js/24.5fdfd386.js"><link rel="prefetch" href="/assets/js/25.f8103722.js"><link rel="prefetch" href="/assets/js/26.0f466743.js"><link rel="prefetch" href="/assets/js/27.1a479f35.js"><link rel="prefetch" href="/assets/js/28.7fc5f2a7.js"><link rel="prefetch" href="/assets/js/29.d46d55e1.js"><link rel="prefetch" href="/assets/js/30.bd3e0843.js"><link rel="prefetch" href="/assets/js/31.5982f7a9.js"><link rel="prefetch" href="/assets/js/32.1df69aa5.js"><link rel="prefetch" href="/assets/js/33.fed706d8.js"><link rel="prefetch" href="/assets/js/34.273f6052.js"><link rel="prefetch" href="/assets/js/36.e5abf0c8.js"><link rel="prefetch" href="/assets/js/37.579136a6.js"><link rel="prefetch" href="/assets/js/38.a5801709.js"><link rel="prefetch" href="/assets/js/39.2c716e6d.js"><link rel="prefetch" href="/assets/js/4.e089175f.js"><link rel="prefetch" href="/assets/js/40.e6a7b64d.js"><link rel="prefetch" href="/assets/js/41.27eaae68.js"><link rel="prefetch" href="/assets/js/42.ccebbe67.js"><link rel="prefetch" href="/assets/js/43.0261f029.js"><link rel="prefetch" href="/assets/js/44.d282729c.js"><link rel="prefetch" href="/assets/js/45.475775aa.js"><link rel="prefetch" href="/assets/js/46.db8c948d.js"><link rel="prefetch" href="/assets/js/47.82311ca2.js"><link rel="prefetch" href="/assets/js/48.1697bdab.js"><link rel="prefetch" href="/assets/js/49.e86be80d.js"><link rel="prefetch" href="/assets/js/5.a6acc31c.js"><link rel="prefetch" href="/assets/js/50.b323a160.js"><link rel="prefetch" href="/assets/js/51.67d7e69d.js"><link rel="prefetch" href="/assets/js/52.f3b55d0f.js"><link rel="prefetch" href="/assets/js/53.baa394f0.js"><link rel="prefetch" href="/assets/js/54.49038f6a.js"><link rel="prefetch" href="/assets/js/55.c9e18ea7.js"><link rel="prefetch" href="/assets/js/56.a4af5049.js"><link rel="prefetch" href="/assets/js/57.be1f8149.js"><link rel="prefetch" href="/assets/js/58.ba689b20.js"><link rel="prefetch" href="/assets/js/59.192f28d9.js"><link rel="prefetch" href="/assets/js/6.56200eb6.js"><link rel="prefetch" href="/assets/js/60.e6f4bdba.js"><link rel="prefetch" href="/assets/js/7.ab8ffd39.js"><link rel="prefetch" href="/assets/js/8.f847aa7a.js"><link rel="prefetch" href="/assets/js/9.a1c872e2.js">
    <link rel="stylesheet" href="/assets/css/0.styles.41761744.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">What is FE</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/programming-basics/编程模式/函数式编程.html" class="nav-link">
  编程基础
</a></div><div class="nav-item"><a href="/syntax&amp;API/HTML/关于HTML.html" class="nav-link">
  语法和API
</a></div><div class="nav-item"><a href="/network/" class="nav-link">
  网络和通讯
</a></div><div class="nav-item"><a href="/development-process/Git/git命令.html" class="nav-link">
  开发流程
</a></div><div class="nav-item"><a href="/engineering/webpack/webpack基础学习.html" class="nav-link">
  前端工程化
</a></div><div class="nav-item"><a href="/runnnig-monitoring/安全/CSRF.html" class="nav-link">
  运行与监控
</a></div><div class="nav-item"><a href="/framework/React/关于react-hook.html" class="nav-link">
  前端框架
</a></div><div class="nav-item"><a href="/tool&amp;plugin/cross-env/关于cross-env.html" class="nav-link">
  常用工具与插件
</a></div><div class="nav-item"><a href="/server/" class="nav-link">
  服务器端
</a></div><div class="nav-item"><a href="/more/" class="nav-link">
  技术广度
</a></div><div class="nav-item"><a href="https://github.com/licop/What_is_FE" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/programming-basics/编程模式/函数式编程.html" class="nav-link">
  编程基础
</a></div><div class="nav-item"><a href="/syntax&amp;API/HTML/关于HTML.html" class="nav-link">
  语法和API
</a></div><div class="nav-item"><a href="/network/" class="nav-link">
  网络和通讯
</a></div><div class="nav-item"><a href="/development-process/Git/git命令.html" class="nav-link">
  开发流程
</a></div><div class="nav-item"><a href="/engineering/webpack/webpack基础学习.html" class="nav-link">
  前端工程化
</a></div><div class="nav-item"><a href="/runnnig-monitoring/安全/CSRF.html" class="nav-link">
  运行与监控
</a></div><div class="nav-item"><a href="/framework/React/关于react-hook.html" class="nav-link">
  前端框架
</a></div><div class="nav-item"><a href="/tool&amp;plugin/cross-env/关于cross-env.html" class="nav-link">
  常用工具与插件
</a></div><div class="nav-item"><a href="/server/" class="nav-link">
  服务器端
</a></div><div class="nav-item"><a href="/more/" class="nav-link">
  技术广度
</a></div><div class="nav-item"><a href="https://github.com/licop/What_is_FE" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>React</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/framework/React/关于react-hook.html" class="sidebar-link">关于 react hook</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>Vue</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/framework/Vue/vue-router实现原理.html" class="sidebar-link">vue-router 实现原理</a></li><li><a href="/framework/Vue/vue数据响应式原理.html" class="active sidebar-link">vue 数据响应式原理</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/framework/Vue/vue数据响应式原理.html#什么是数据响应式" class="sidebar-link">什么是数据响应式</a></li><li class="sidebar-sub-header"><a href="/framework/Vue/vue数据响应式原理.html#响应式核心原理" class="sidebar-link">响应式核心原理</a></li><li class="sidebar-sub-header"><a href="/framework/Vue/vue数据响应式原理.html#发布订阅模式和观察者模式" class="sidebar-link">发布订阅模式和观察者模式</a></li><li class="sidebar-sub-header"><a href="/framework/Vue/vue数据响应式原理.html#响应式实现模拟" class="sidebar-link">响应式实现模拟</a></li><li class="sidebar-sub-header"><a href="/framework/Vue/vue数据响应式原理.html#更多参考" class="sidebar-link">更多参考</a></li></ul></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="vue-数据响应式原理"><a href="#vue-数据响应式原理" class="header-anchor">#</a> vue 数据响应式原理</h1> <h2 id="什么是数据响应式"><a href="#什么是数据响应式" class="header-anchor">#</a> 什么是数据响应式</h2> <p>Vue.js 一个核心思想是<strong>数据驱动</strong>。所谓数据驱动，是指视图是由数据驱动生成的，我们对视图的修改，不会直接操作 DOM，而是通过修改数据。</p> <p>为实现数据驱动，需要将数据变成<strong>响应式</strong>的，数据模型仅仅是普通的 javascript 对象，而当我们修改数据时，视图会进行更新，避免 DOM 操作，提高开发效率。</p> <p>与 React 的<strong>单项数据流不同</strong>，Vue 实现了<strong>双向绑定</strong>即数据改变，视图改变；视图改变，数据也随之改变。可以使用 <code>v-modal</code> 在表单元素上创建双向数据绑定。</p> <h2 id="响应式核心原理"><a href="#响应式核心原理" class="header-anchor">#</a> 响应式核心原理</h2> <p>根据官方文档<a href="https://cn.vuejs.org/v2/guide/reactivity.html" target="_blank" rel="noopener noreferrer">深入响应式原理<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>的解释，在 Vue2.x 中，当你把一个普通的 JavaScript 对象传入 Vue 实例作为 <code>data</code> 选项，Vue 将遍历此对象所有的 property，并使用 <code>Object.defineProperty</code> 把这些 property 全部转为 <code>getter/setter</code>。</p> <p>代码模拟</p> <div class="language- extra-class"><pre class="language-text"><code>// 模拟 Vue 中的 data 选项
let data = {
  msg: 'hello',
  count: 10
}

// 模拟 Vue 的实例
let vm = {}

proxyData(data)

function proxyData(data) {
  // 遍历 data 对象的所有属性
  Object.keys(data).forEach(key =&gt; {
    // 数据劫持：当访问或者设置 vm 中的成员的时候，做一些干预操作
    // 把 data 中的属性，转换成 vm 的 setter/setter
    Object.defineProperty(vm, key, {
      // 可枚举（可遍历）
      enumerable: true,
      // 可配置（可以使用 delete 删除，可以通过 defineProperty 重新定义）
      configurable: true,
      // 当获取值的时候执行
      get () {
        console.log('get: ', key, data[key])
        return data[key]
      },
      // 当设置值的时候执行
      set (newValue) {
        console.log('set: ', key, newValue)
        if (newValue === data[key]) {
          return
        }
        data[key] = newValue
        // 数据更改，更新 DOM 的值
        document.querySelector('#app').textContent = data[key]
      }
    })
  })
}

// 测试
vm.msg = 'Hello World'
vm.count = '9'
console.log(vm.msg)  // 'Hello World'
console.log(data.msg) // 'Hello World'
</code></pre></div><p>在 vue3.0 中则使用<code>proxy</code>代替<code>Object.defineProperty</code>进行数据劫持，直接监听对象，而非属性，所以不用遍历对象。<code>proxy</code>是 ES 6 中新增的特性，性能由浏览器优化，所以比<code>Object.defineProperty</code>更快一点。更多关于<code>proxy</code>的介绍参考<a href="https://what-is-fe.licop.cn/syntax&amp;API/ES%E8%AF%AD%E6%B3%95/ECMAScript%202015%20%E8%AF%AD%E6%B3%95.html#proxy" target="_blank" rel="noopener noreferrer">Proxy<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p>代码模拟</p> <div class="language- extra-class"><pre class="language-text"><code>// 模拟 Vue 中的 data 选项
let data = {
  msg: 'hello',
  count: 0
}

// 模拟 Vue 实例
let vm = new Proxy(data, {
  // 执行代理行为的函数
  // 当访问 vm 的成员会执行
  get (target, key) {
    console.log('get, key: ', key, target[key])
    return target[key]
  },
  // 当设置 vm 的成员会执行
  set (target, key, newValue) {
    console.log('set, key: ', key, newValue)
    if (target[key] === newValue) {
      return
    }
    target[key] = newValue
    document.querySelector('#app').textContent = target[key]
  }
})

// 测试
vm.msg = 'Hello World'
console.log(vm.msg)
</code></pre></div><h2 id="发布订阅模式和观察者模式"><a href="#发布订阅模式和观察者模式" class="header-anchor">#</a> 发布订阅模式和观察者模式</h2> <p><strong>什么是发布订阅模式？</strong></p> <p>我们假定，存在一个&quot;信号中心&quot;，某个任务执行完成，就向信号中心&quot;发布&quot;(publish)一个信号，其他任务可以向信号中心&quot;订阅&quot;(subscribe)这个信号，从而知道什么时候自己可以开始执行。这就叫做 <strong>&quot;发布/订阅模式&quot;(publish-subscribe pattern)</strong></p> <p>vue 中的兄弟组件通信过程就是发布订阅模式, B 组件向消息中心<strong>订阅</strong>了<code>add-todo</code>信号，并注册了执行函数<code>this.addTodo</code>,然后在 A 组件中<strong>发布</strong><code>add-todo</code>信号，并传递了参数，B 组件通过事件中心<code>eventHub</code>接收到信号，然后开始执行<code>this.addTodo</code>接受 A 组件传递过来的参数，完成组件件的通信。</p> <div class="language- extra-class"><pre class="language-text"><code>// eventBus.js
// 事件中心
let eventHub = new Vue()

// ComponentA.vue
// 发布者
addTodo: function () {
  // 发布消息(事件)
  eventHub.$emit('add-todo', { text: this.newTodoText })
  this.newTodoText = ''
}

// ComponentB.vue
// 订阅者
created: function () {
  // 订阅消息(事件)
  eventHub.$on('add-todo', this.addTodo)
}
</code></pre></div><p>代码实现事件中心，实现发布订阅机制</p> <div class="language- extra-class"><pre class="language-text"><code>// 事件触发器
class EventEmitter {
  constructor() {
    // { eventType: [ handler1, handler2 ] }
    this.subs = Object.create(null)
  }
  // 注册事件
  $on(eventTpye, handler) {
    this.subs[eventTpye] = this.subs[eventTpye] || [];
    this.subs[eventTpye].push(handler)
  }
  // 触发事件
  $emit() {
    // 第一个参数是对应的 event 值，直接用数组的 shift 方法取出
    let eventTpye = [].shift.call(arguments);
    if(this.subs[eventTpye]) {
      this.subs[eventTpye].forEach(handler =&gt; {
        handler.apply(this, arguments)
      })
    }
  }
}

const em = new EventEmitter()

em.$on('click', () =&gt; {
  console.log('click 1')
})
em.$on('click', (content) =&gt; {
  console.log('click 2', content)
})
em.$emit('click', 'emit')
</code></pre></div><p><strong>什么是观察者模式？</strong></p> <p>我们假设你正在找一份软件工程师的工作，对“香蕉公司”很感兴趣。所以你联系了他们的 HR，给了他你的联系电话。他保证如果有任何职位空缺都会通知你。这里还有几个候选人也你一样很感兴趣。所以职位空缺大家都会知道，如果你回应了他们的通知，他们就会联系你面试。
所以，以上和“观察者模式”有什么关系呢？这里的“香蕉公司”就是<strong>发布者(Dependency）</strong>，用来维护<strong>观察者(Watcher)</strong>（和你一样的候选人），为某些 event（比如职位空缺）来 <strong>通知（notify)</strong> 观察者。</p> <p>所以观察者模式没有发布订阅模式下的事件中心，观察者模式的订阅者与发布者之间是存在依赖的。</p> <p>代码模拟观察者模式</p> <ul><li>观察者(订阅者) -- Watcher
<ul><li>update():当事件发生时，具体要做的事情</li></ul></li> <li>目标(发布者) -- Dep
<ul><li>subs 数组:存储所有的观察者</li> <li>addSub():添加观察者</li> <li>notify():当事件发生，调用所有观察者的 update() 方法</li></ul></li></ul> <div class="language- extra-class"><pre class="language-text"><code> // 发布者-目标
class Dep {
  constructor () {
    // 记录所有的订阅者
    this.subs = []
  }
  // 添加订阅者
  addSub (sub) {
    if (sub &amp;&amp; sub.update) {
      this.subs.push(sub)
    }
  }
  // 发布通知
  notify () {
    this.subs.forEach(sub =&gt; {
      sub.update()
    })
  }
}
// 订阅者-观察者
class Watcher1 {
  update () {
    console.log('Watcher1')
  }
}
class Watcher2 {
  update () {
    console.log('Watcher2')
  }
}

// 测试
let dep = new Dep()
let watcher1 = new Watcher1()
let watcher2 = new Watcher2()
dep.addSub(watcher1)
dep.addSub(watcher2)

dep.notify()
</code></pre></div><p><strong>发布订阅和观察者模式之间的区别</strong></p> <ul><li><strong>观察者模式</strong>是由具体目标调度，比如当事件触发，Dep 就会去调用观察者的方法，所以观察者模式的订阅者与发布者之间是存在依赖的。</li> <li><strong>发布/订阅模式</strong>由统一调度中心调用，因此发布者和订阅者不需要知道对方的存在。</li></ul> <p><img src="/framework/sub_pub.png" alt=""></p> <h2 id="响应式实现模拟"><a href="#响应式实现模拟" class="header-anchor">#</a> 响应式实现模拟</h2> <h3 id="功能需求"><a href="#功能需求" class="header-anchor">#</a> 功能需求</h3> <p>下面来模拟 Vue 响应式,实现一个 小型的 Vue 来模拟下面的功能：</p> <ul><li>Vue 支持<code>el</code>，<code>data</code>，<code>methods</code>选项</li> <li><code>data</code>数据变成响应式, 改变数据，视图也随之改变</li> <li>模板编译<strong>差值表达式</strong></li> <li>实现<code>v-text</code>,<code>v-modal</code>,<code>v-on</code>和<code>v-html</code>指令</li> <li><code>v-modal</code>实现双向绑定语法糖，改变视图，数据也会随之改变</li> <li><code>methods</code>中的方法绑定<code>this</code>指向 Vue 实例</li></ul> <div class="language- extra-class"><pre class="language-text"><code>&lt;div id=&quot;app&quot;&gt;
  &lt;h1&gt;差值表达式&lt;/h1&gt;
  &lt;h3&gt;{{ msg }}&lt;/h3&gt;
  &lt;h3&gt;{{ count }}&lt;/h3&gt;
  &lt;h1&gt;v-text&lt;/h1&gt;
  &lt;div v-text=&quot;msg&quot;&gt;&lt;/div&gt;
  &lt;h1&gt;v-model&lt;/h1&gt;
  &lt;input type=&quot;text&quot; v-model=&quot;msg&quot;&gt;
  &lt;input type=&quot;text&quot; v-model=&quot;count&quot;&gt;
  &lt;p v-html=&quot;html&quot;&gt;&lt;/p&gt;
  &lt;button v-on:click=&quot;changeColor()&quot;&gt;点击改变color&lt;/button&gt;
  &lt;button v-on:click=&quot;print(count, 10, 'licop')&quot;&gt;点击打印count&lt;/button&gt;
&lt;/div&gt;
&lt;script&gt;
  let vm = new Vue({
    el: '#app',
    data: {
      msg: 'Hello Vue',
      count: 20,
      person: {
        name: 'licop'
      },
      html: '&lt;span style=&quot;color: red&quot;&gt;red&lt;/span&gt;',
      items: ['a', 'b', 'c']
    },
    methods: {
      print(count, num, str) {
        console.log(count, num, str)
        console.log(this.msg)
      },
      changeColor: function () {
        this.html = '&lt;span style=&quot;color: blue&quot;&gt;blue&lt;/span&gt;'
      }
    }
  })
  // vm.msg = {
  //   test: 'try'
  // }
&lt;/script&gt;

</code></pre></div><h3 id="整体结构"><a href="#整体结构" class="header-anchor">#</a> 整体结构</h3> <p>Vue 响应式是通过<strong>数据拦截</strong>和<strong>观察者模式</strong>实现的，外加<strong>编译模板</strong>功能，综合上边对响应式核心原理和观察者模式的介绍，所以实现一个简易的 Vue 需要 5 个模块</p> <ul><li><strong>Vue</strong>: 把 data 中的成员注入到 Vue 实例，并且把 data 中的成员转成 getter/setter,调用<code>Observer</code>和<code>Compiler</code></li> <li><strong>Observer</strong>: 能够对数据对象的所有属性进行监听，如有变动可拿到最新值并通知 Dep</li> <li><strong>Compiler</strong>: 解析每个元素中的指令/插值表达式，并替换成相应的数据</li> <li><strong>Dep</strong>: 添加观察者(watcher)，当数据变化通知所有观察者</li> <li><strong>Watcher</strong>: 数据变化更新视图</li></ul> <p><strong>整体结构</strong> <img src="/framework/Vue%E5%93%8D%E5%BA%94%E5%BC%8F.png" alt=""></p> <p>下面分别介绍每个模块：</p> <h3 id="vue"><a href="#vue" class="header-anchor">#</a> Vue</h3> <p><code>new Vue()</code>初始化<code>Vue</code>实例，代码入口</p> <p><strong>功能</strong></p> <ul><li>负责接收初始化的参数(选项)</li> <li>负责把 <code>data</code> 中的属性注入到 Vue 实例，转换成 getter/setter</li> <li>负责把 <code>methods</code>里方法的 this 绑定到 Vue 实例</li> <li>负责调用 <code>observer</code> 监听 data 中所有属性的变化</li> <li>负责调用 <code>compiler</code> 解析指令/插值表达式</li></ul> <p><strong>代码</strong></p> <div class="language- extra-class"><pre class="language-text"><code>class Vue {
  constructor (options) {
    // 通过属性保存选项中的数据
    this.$options = options || {};
    this.$data = options.data || {};
    this.$methods= options.methods || {};
    this.$el = typeof options.el === 'string' ? document.querySelector(options.el) : options.el

    // 把data中的成员转换成getter和setter，注入到vue实例中
    this._proxyData(this.$data)
    // 将methods里的方法this绑定到Vue实例，使其能够获取Vue的属性和方法
    this._bindMethods(options.methods)
    // 调用observer对象，使用getter和setter监听数据读取和变更
    new Observer(this.$data)
    // 调用compiler对象，解析指令和差值表达式
    new Compiler(this)
  }

  _proxyData (data) {
    // 遍历data中的所有属性
    Object.keys(data).forEach(key =&gt; {
      Object.defineProperty(this, key, {
        enumerable: true,
        configurable: true,
        get () {
          return data[key]
        },
        set (newValue) {
          if(newValue === data[key]) {
            return
          }
          data[key] = newValue
        }
      })
    })
  }

  _bindMethods (methods) {
    Object.keys(methods).forEach(key =&gt; {
      this.$methods[key] = methods[key].bind(this)
    })
  }
}

</code></pre></div><h3 id="observer"><a href="#observer" class="header-anchor">#</a> Observer</h3> <p><code>Observer</code>类负责<strong>数据劫持</strong></p> <p><strong>功能</strong></p> <ul><li>负责把 data 选项中的属性转换成<strong>响应式</strong>数据</li> <li>data 中的某个属性也是对象，利用递归把该属性转换成<strong>响应式</strong>数据</li> <li>如果给属性赋值为新对象，把新对象的成员设置为 <code>getter/setter</code>转换成<strong>响应式</strong>数据</li> <li><code>setter</code>方法监听属性访问，调用<code>dep.addSub()</code>给 <code>Dep</code> 实例添加 <code>Watcher</code> 依赖</li> <li><code>getter</code>方法监听属性变更，调用 <code>dep.notify()</code>给<code>Dep</code> 实例发送通知</li></ul> <p><code>new Vue</code>初始化的时候完成<code>data</code>里属性转换成<strong>响应式</strong>数据，所以后期想给实例添加属性，或者使用<code>methods</code>方法给<code>data</code>里的对象属性添加新的属性则不会变成响应式的。如果想把属性变成响应式参考<a href="https://cn.vuejs.org/v2/guide/reactivity.html" target="_blank" rel="noopener noreferrer">文档<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p>如果给属性重新赋值成一个对象则会变成<strong>响应式</strong>的，因为属性在<code>data</code>定义过，当重新赋值的时候会触发<code>setter</code>方法，然后遍历对象的属性变成<strong>响应式</strong>的。</p> <p><strong>代码</strong></p> <div class="language- extra-class"><pre class="language-text"><code>class Observer {
  constructor (data) {
    this.walk(data)
  }

  walk (data) {
    // 判断data是否是对象
    if(!data || typeof data !== 'object') {
      return
    }
    // 遍历data对象所有属性
    Object.keys(data).forEach(key =&gt; {
      this.defineReactive(data, key, data[key])
    })
  }

  defineReactive (obj, key, val) {
    let that = this
    // dep负责收集依赖，并发送通知
    let dep = new Dep()
    // 如果val是对象，把val内部的属性转化为响应式数据
    this.walk(val)

    Object.defineProperty(obj, key, {
      enumerable: true,
      configurable: true,
      // 如果返回obj[key]会造成死递归，因为每次访问obj[key]都会调用get方法，造成堆栈溢出
      get () {
        // 收集依赖，Dep.target为Watcher实例
        Dep.target &amp;&amp; dep.addSub(Dep.target)
        return val
      },
      set (newValue) {
        if(newValue === val) {
          return
        }
        val = newValue
        // 如果属性被赋予新的值是对象，newValue内部属性转化为响应式
        that.walk(newValue)
        // 向Watcher实例发送通知，更新update()
        dep.notify()
      }
    })
  }
}
</code></pre></div><h3 id="compiler"><a href="#compiler" class="header-anchor">#</a> Compiler</h3> <ul><li>负责编译模板，解析指令/插值表达式</li> <li>负责页面的首次渲染</li> <li>在数据变化，视图需要改变的地方，添加 <code>Wathcher</code> 实例，当数据变化后执行回调函数，重新渲染视图</li></ul> <div class="language- extra-class"><pre class="language-text"><code>class Compiler {
  constructor (vm) {
    this.el = vm.$el
    this.vm = vm
    this.compile(this.el)
  }
  // 编译模板，处理本文节点和元素节点
  compile (el) {
    let childNodes = el.childNodes;
    // 伪数组变成数组
    Array.from(childNodes).forEach(node =&gt; {
      if(this.isTextNode(node)) {
        this.compileText(node)
      } else if(this.isElementNode(node)) {
        this.compileElement(node)
      }
      // 判断node是否有子节点，如果有递归调用compiler
      if(node.childNodes &amp;&amp; node.childNodes.length !== 0) {
        this.compile(node)
      }
    })
  }
  // 编译元素节点，处理指令
  compileElement (node) {
    // 遍历所有的属性节点，判断是否是指令
    Array.from(node.attributes).forEach(attr =&gt; {
      // 判断是否是指令
      let attrName = attr.name
      if(this.isDirective(attrName)) {
        // v-text --&gt; text
        attrName = attrName.substr(2)
        let key = attr.value
        this.update(node, key, attrName)
      }
    })
  }

  update (node, key, attrName) {
    let updateFn = this[attrName.split(':')[0] + 'Updater']
    updateFn &amp;&amp; updateFn(node, key, attrName)
  }

  // 处理v-text指令
  textUpdater = (node, key) =&gt; {
    node.textContent = this.vm[key]
    new Watcher(this.vm, key, () =&gt; {
      node.textContent = this.vm[key]
    })
  }

  // 处理v-model指令
  modelUpdater = (node, key) =&gt; {
    node.value = this.vm[key]
    new Watcher(this.vm, key, () =&gt; {
      node.value = this.vm[key]
    })

    // 双向绑定, 语法糖
    node.addEventListener('input', () =&gt; {
      this.vm[key] = node.value
    })
  }

  // 处理v-html指令
  htmlUpdater = (node, key) =&gt; {
    node.innerHTML = this.vm[key]

    new Watcher(this.vm, key, () =&gt; {
      node.innerHTML = this.vm[key]
    })
  }

  // 处理v-on指令
  onUpdater = (node, key, attrName) =&gt; {
    const event = attrName.split(':')[1]
    // 匹配函数名和参数
    const reg = /(.+?)\((.+?|\s?)\)/
    if(reg.test(key)) {
      let fnKey = RegExp.$1.trim()
      let args = RegExp.$2.trim()
      if(args) {
        args = args.split(',').map(arg =&gt; {
          let _arg = arg.replace(/\s+/, '')
           // todo 这里只实现了参数是数字，字符串和data里属性的情形
          if(_arg.startsWith('&quot;') ||  _arg.startsWith(&quot;'&quot;)) {
            return _arg.slice(1, _arg.length - 1)
          } else if(Number(_arg)) {
              return Number(_arg)
          }
          return this.vm.$data[_arg]
        })
      } else {
        args = []
      }
      node.addEventListener(event, () =&gt; { this.vm.$methods &amp;&amp; this.vm.$methods[fnKey](...args) });
    }
  }

  // 编译文本节点，处理差值表达式 {{ msg }}
  compileText (node) {
    let reg = /\{\{(.+?)\}\}/
    let value = node.textContent
    if (reg.test(value)) {
      // 将花括号里的值提取出来,正则表达式里使用小括号包裹
      let key = RegExp.$1.trim()
      node.textContent = value.replace(reg, this.vm[key])

      // 创建watcher对象，当数据改变更新视图
      new Watcher(this.vm, key, (newValue) =&gt; {
        console.log(key, newValue);
        node.textContent = newValue
      })
    }
  }
  // 判断元素属性是否是执行
  isDirective (attrName) {
    return attrName.startsWith('v-')
  }
  // 判断节点是否是本文节点
  isTextNode (node) {
    return node.nodeType === 3
  }
  // 判断节点是否是元素节点
  isElementNode (node) {
    return node.nodeType === 1
  }
}
</code></pre></div><h3 id="dep"><a href="#dep" class="header-anchor">#</a> Dep</h3> <p><strong>功能</strong></p> <ul><li>每个属性对应一个 Dep 实例</li> <li><code>addSub()</code>负责收集依赖</li> <li><code>notify()</code>想依赖发起通知，调用依赖中的<code>update()</code>方法</li></ul> <p><strong>代码</strong></p> <div class="language- extra-class"><pre class="language-text"><code>class Dep {
  constructor () {
    // 存储所有的观察者
    this.subs = []

  }
  // 添加观察者
  addSub (sub) {
    if (sub &amp;&amp; sub.update) {
      this.subs.push(sub)
    }
  }
  // 发送通知
  notify () {
    this.subs.forEach(sub =&gt; {
      sub.update()
    })
  }
}
</code></pre></div><h3 id="watcher"><a href="#watcher" class="header-anchor">#</a> Watcher</h3> <p><strong>功能</strong></p> <ul><li>页面中所有依赖数据的地方都需要创建一个 <code>Watcher</code>实例</li> <li><code>Watcher</code>自身实例化的时候往 dep 对象中添加自己</li> <li>当数据变化触发依赖， <code>dep</code>通知所有的 <code>Watcher</code> 实例更新视图</li> <li><code>Watcher</code>必须拥有一个<code>update</code>方法，当值发生变化的时候触发回调函数</li></ul> <div class="language- extra-class"><pre class="language-text"><code>class Watcher {
  constructor (vm, key, cb) {
    this.vm = vm
    // data中的属性名称
    this.key = key
    // 回调函数负责更新视图
    this.cb = cb

    // 把watcher对象记录到Dep类的静态属性target中 ?为何添加到Dep中，添加到Watcher也可工作
    Dep.target = this;
    // 触发get方法，在get方法中调用addSub
    this.oldValue = vm[key]

    Dep.target = null;
  }

  // 当数据发生变化的时候更新视图
  update () {
    let newValue = this.vm[this.key]
    if (this.oldValue === newValue) {
      return
    }
    // 更新视图
    this.cb(newValue)
  }
}
</code></pre></div><p><a href="https://github.com/licop/vue-reactivity" target="_blank" rel="noopener noreferrer">完整代码参考<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <h2 id="更多参考"><a href="#更多参考" class="header-anchor">#</a> 更多参考</h2> <ul><li><a href="https://cn.vuejs.org/v2/guide/reactivity.html" target="_blank" rel="noopener noreferrer">官方文档 深入响应式原理<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="https://github.com/DMQ/mvvm" target="_blank" rel="noopener noreferrer">剖析 Vue 实现原理 - 如何实现双向绑定 mvvm<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="https://juejin.cn/post/6844903513009422343" target="_blank" rel="noopener noreferrer">观察者模式 vs 发布-订阅模式<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="https://tool.oschina.net/uploads/apidocs/jquery/regexp.html" target="_blank" rel="noopener noreferrer">正则表达式文档<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/framework/Vue/vue-router实现原理.html" class="prev">
        vue-router 实现原理
      </a></span> <!----></p></div> </main></div><div class="global-ui"><!----><!----></div></div>
    <script src="/assets/js/app.95b0f20d.js" defer></script><script src="/assets/js/2.5e2d37c1.js" defer></script><script src="/assets/js/35.1a00cbbe.js" defer></script><script src="/assets/js/3.b304fdc1.js" defer></script>
  </body>
</html>
